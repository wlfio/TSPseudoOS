{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/Services/FileSystem.ts","webpack:///./src/Struct/Identity.ts","webpack:///./src/Services/Display.ts","webpack:///./src/app.ts","webpack:///./src/Services/ProcessManager.ts","webpack:///./src/Struct/Process.ts","webpack:///./src/Struct/OSLib.ts","webpack:///./src/Struct/Util.ts","webpack:///./src/Services/Cmd.ts","webpack:///./src/App/Default/index.ts","webpack:///./src/App/Default/ls.ts","webpack:///./src/App/Default/bash.ts","webpack:///./src/App/Default/mkdir.ts","webpack:///./src/App/Default/cat.ts","webpack:///./src/App/Default/touch.ts","webpack:///./src/App/Default/rm.ts","webpack:///./src/App/Default/cd.ts","webpack:///./src/App/Default/tail.ts","webpack:///./src/App/Default/head.ts","webpack:///./src/App/Default/edit.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","slashWrap","path","charAt","length","fixPath","split","reduce","out","inp","slice","join","filePath","indexOf","dirPath","permPath","owndPath","getPathOwners","localStorage","getItem","getPathOwnerString","getPathUsr","getPermBits","parseInt","permStringPart","action","ps","permString","perms","getPermBitsUsr","getPermBitsGrp","getPermBitsAny","groupHasPermission","identity","groups","includes","getPathGrp","hasPermission","user","priveledged","userHasPermission","anyHasPermission","getFileName","pop","getFileExt","parts","isDir","createRoot","doMkdir","isDirCheck","console","trace","Error","getFileDir","hasPermissionCheck","hasDirPermissionCheck","dirExistsCheck","doFileExists","fileExists","identC","getIdentity","resolvePath","Promise","resolve","fileExistsCheck","dirExists","identitC","resolveWorkingPath","working","trim","check","replace","workingDir","dirAccessCheck","resolveWorkingPaths","paths","map","doChmod","usr","grp","any","setItem","toString","chmod","hex","e","reject","doChown","group","chown","permBitRead","mkdir","fileDirExistsCheck","fileNotExistsCheck","write","content","exists","doWrite","touch","doRead","read","append","newContent","then","wrt","catch","del","removeItem","doDel","delDir","keys","forEach","startsWith","doDelDir","list","log","f","filter","file","getChildren","rootPath","entry","dir","ownerData","full","ext","permBytes","size","Blob","listEntry","sort","a","b","getExec","exec","getEnv","resolveExecPaths","str","cleanSlash","execRead","data","Identity","env","this","toLowerCase","setEnv","Array","fallback","clone","priveleged","ident","setPriveledged","entries","pm","text","over","newLine","queuedItems","processManager","display","document","createElement","input","createDisplay","addEventListener","activeElement","focus","ev","ctrlKey","repeat","controlKey","enterText","tabKey","preventDefault","history","processQueue","txt","span","colours","setAttribute","textContent","elements","index","array","colourizeText","push","insertBefore","level","type","reduceArrayForDisplay","processDisplayData","items","breakUptext","writeToDisplay","scrollToBottom","scrollTo","scrollHeight","show","item","id","tabIndex","classList","add","contentEditable","spellcheck","body","querySelector","specialUserInput","inputOutput","range","createRange","Range","sel","window","getSelection","Selection","childs","childNodes","setStart","collapse","removeAllRanges","addRange","userInput","setText","output","stdIn","rootIdent","guestIdent","isRemote","self","top","InIframe","DefaultApps","app","re","location","host","init","startProcess","processes","pids","pending","libJS","mainProcess","pid","processID","process","getProcessFromID","kill","source","params","parent","execData","execPath","code","proc","start","values","find","StubDisplay","Process","manager","dead","children","parentInCB","parentEndCB","parentID","api","Std","hasParent","intoParent","Display","print","in","intoChild","FS","end","prop","crash","error","changeWorkingPath","prompt","getDisplay","printLn","info","lib","signature","cbs","registerChild","event","wrapper","eval","service","func","removeChild","from","fireEvent","endProcess","hooks","awaitProcs","cb","hookEvent","msg","startAndAwaitOutput","startAndAwait","printRaw","Util","CMD","_call","fireHooks","awaitIn","loadArgs","args","opts","remain","arg","JSON","stringify","j","shrt","bytesToHuman","bytes","kibi","bits","step","set","Math","round","hexCheck","test","testColourHex","Colours","red","green","blue","black","white","lightBlue","Colourize","fore","back","toUpperCase","ls","bash","cat","rm","cd","tail","head","edit","OS","all","human","long","raw","count","done","argMap","h","G","formatFileName","arr","longOutputEntry","result","longOutput","shortOutput","bashHistoryFile","origin","activeProcessID","activeOutputed","subProcs","historyPosition","bashProcess","selfUpdate","pos","min","max","setHistoryPosition","match","printPrompt","getSubProc","splitUserInput","dirs","ctrlCode","showHistory","tabComplete","specialCode","shift","er","message","newHistory","resolveAppIn","help","version","options","verbose","parents","optMap","v","breakPathIntoParentPaths","rawPaths","prefix","broken","breakPathsIntoParentPaths","make","number","lines","empty","line","splitLines","firstOut","run","printOutput","recursive","printDirError","follow","files","readFiles","PROCESS","bob"],"mappings":"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","file":"os.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","import { IIdentity, IIdentityContainer } from \"../Struct/Identity\";\n\nconst dirString: string = \"___dir___\";\n\nconst cleanSlash: Function = (str: string) => str.replace(/\\//g, \"\");\n\nconst slashWrap: Function = (path: string): string => {\n    if (path.charAt(0) !== \"/\") {\n        path = \"/\" + path;\n    }\n    if (path.charAt(path.length - 1) !== \"/\") {\n        path += \"/\";\n    }\n    return path;\n};\n\nconst fixPath: Function = (path: string) => {\n    return \"/\" + path.split(\"/\").reduce((out: string[], inp: string) => {\n        if (inp.length > 0 && inp !== \".\") {\n            if (inp === \"..\") {\n                return out.slice(0, out.length - 1);\n            } else {\n                return [...out, inp];\n            }\n        }\n        return out;\n    }, []).join(\"/\");\n};\n\nconst filePath: Function = (path: string) => path.indexOf(\"FSF:\") !== 0 ? \"FSF:\" + fixPath(path) : path;\nconst dirPath: Function = (path: string) => path.indexOf(\"FSD:\") !== 0 ? \"FSD:\" + fixPath(path) : path;\nconst permPath: Function = (path: string) => path.indexOf(\"FSP:\") !== 0 ? \"FSP:\" + fixPath(path) : path;\nconst owndPath: Function = (path: string) => path.indexOf(\"FSO:\") !== 0 ? \"FSO:\" + fixPath(path) : path;\n\n\nconst getPathOwnerString: Function = (path: string): string => localStorage.getItem(owndPath(path)) || \"nobody:nobody\";\nconst getPathOwners: Function = (path: string): string[] => getPathOwnerString(path).split(\":\");\nconst getPathUsr: Function = (path: string) => getPathOwners(path)[0];\nconst getPathGrp: Function = (path: string) => getPathOwners(path)[1];\n\n\nconst permBitRead: number = 4;\nconst permBitWrit: number = 2;\nconst permBitExec: number = 1;\n\nconst bitOffsetUsr: number = 8;\nconst bitOffsetAny: number = 0;\nconst bitOffsetGrp: number = 4;\n\nconst getPermBits: Function = (path: string): number => parseInt(localStorage.getItem(permPath(path)) || \"\", 16);\n\n// tslint:disable: no-bitwise\n\nconst permStringPart: Function = (action: number): string => {\n    let ps: string = \"\";\n    ps += (action & permBitRead) ? \"r\" : \"-\";\n    ps += (action & permBitWrit) ? \"w\" : \"-\";\n    ps += (action & permBitExec) ? \"x\" : \"-\";\n    return ps;\n};\n\nconst permString: Function = (perms: number): string => {\n    return permStringPart(perms >> bitOffsetUsr)\n        + permStringPart(perms >> bitOffsetGrp)\n        + permStringPart(perms >> bitOffsetAny);\n};\n\nconst getPermBitsUsr: Function = (path: string): number => getPermBits(path) >> bitOffsetUsr;\nconst getPermBitsGrp: Function = (path: string): number => getPermBits(path) >> bitOffsetGrp;\nconst getPermBitsAny: Function = (path: string): number => getPermBits(path) >> bitOffsetAny;\n\nconst userHasPermission: Function = (path: string, action: number, identity: IIdentity) => {\n    const user: string = identity.user;\n    if (identity.priveledged) {\n        if (action & permBitExec) {\n            return (\n                (getPermBitsUsr(path) & permBitExec)\n                ||\n                (getPermBitsGrp(path) & permBitExec)\n                ||\n                (getPermBitsAny(path) & permBitExec)\n            );\n        }\n        return true;\n    }\n    if (user === getPathUsr(path) && getPermBitsUsr(path) & action) {\n        return true;\n    }\n    return false;\n};\n\nconst groupHasPermission: Function = (path: string, action: number, identity: IIdentity) => {\n    const groups: string[] = identity.groups;\n    if (groups.includes(getPathGrp(path)) && getPermBitsGrp(path) & action) {\n        return true;\n    }\n    return false;\n};\n\nconst anyHasPermission: Function = (path: string, action: number): boolean => {\n    if (getPermBitsAny(path) & action) {\n        return true;\n    }\n    return false;\n};\n// tslint:enable: no-bitwise\n\n\nconst hasPermission: Function = (path: string, action: number, identity: number) => {\n    return (\n        userHasPermission(path, action, identity)\n        ||\n        groupHasPermission(path, action, identity)\n        ||\n        anyHasPermission(path, action)\n    );\n};\n\n\nconst getFileName: Function = (path: string): string => path.split(\"/\").pop() || \"\";\n\nconst getFileExt: Function = (path: string): string => {\n    const parts: string[] = getFileName(path).split(\".\");\n    return parts.length > 1 ? parts.pop() || \"\" : \"\";\n};\n\nconst isDir: Function = (path: string) => {\n    if (path.length < 1 || path === \"/\") {\n        path = \"/\";\n    }\n    return localStorage.getItem(dirPath(path)) === dirString;\n};\n\nexport const createRoot: Function = (identity: IIdentity): void => {\n    doMkdir(\"/\", identity);\n}\n\nconst isDirCheck: Function = (path: string) => {\n    if (!isDir(path)) {\n        console.trace();\n        throw new Error([\"Access Error\", \"Path is not directory\", path].join(\" : \"));\n    }\n};\n\nconst getFileDir: Function = (path: string): string => {\n    const parts: string[] = path.split(\"/\");\n    path = parts.slice(0, parts.length - 1).join(\"/\");\n    return path;\n};\n\n\nconst hasPermissionCheck: Function = (path: string, action: number, identity: IIdentity) => {\n    if (!hasPermission(path, action, identity)) {\n        throw new Error([\"Permissions Error\", \"Denied \" + permStringPart(action), path].join(\" : \"));\n    }\n};\nconst hasDirPermissionCheck: Function = (path: number, action: number, identity: number) =>\n    hasPermissionCheck(getFileDir(path), action, identity);\n\nconst dirAccessCheck: Function = (path: string, identity: IIdentity) => {\n    path = getFileDir(path);\n    const parts: string[] = path.split(\"/\");\n    for (let i: number = 2; i <= parts.length; i++) {\n        const p: string = parts.slice(0, i).join(\"/\");\n        isDirCheck(p);\n        hasPermissionCheck(p, permBitExec, identity);\n    }\n};\n\n\n\nconst dirExistsCheck: Function = (path: string) => {\n    if (!isDir(path)) {\n        throw new Error([\"Access Error\", \"Cannot access '\" + path + \"': No such file or directory\", path].join(\" : \"));\n    }\n};\n\nconst doFileExists: Function = (path: string): boolean => {\n    return localStorage.getItem(filePath(path)) !== null;\n};\n\nexport const fileExists: Function = (path: string, identC: IIdentityContainer) => {\n    const identity: IIdentity = identC.getIdentity();\n    path = resolvePath(path, identity);\n    return Promise.resolve(doFileExists(path));\n}\n\nconst fileDirExistsCheck: Function = (path: string): void => {\n    path = getFileDir(path);\n    isDirCheck(path);\n};\n\n\nconst fileExistsCheck: Function = (path: string) => {\n    if (!doFileExists(path)) {\n        throw new Error([\"Access Error\", \"Cannot access '\" + path + \"': No such file\", path].join(\" : \"));\n    }\n};\n\nconst fileNotExistsCheck: Function = (path: string) => {\n    if (doFileExists(path)) {\n        throw new Error([\"Access Error\", \"Path exists\", path].join(\" : \"));\n    }\n};\n\nexport const dirExists: Function = (path: string, identitC: IIdentityContainer) => {\n    const identity: IIdentity = identitC.getIdentity();\n    path = resolvePath(path, identity);\n    return Promise.resolve(isDir(path));\n};\n\nconst resolveWorkingPath: Function = (path: string, working: string): string => {\n    working = slashWrap(working || \"/\");\n    path = path.trim();\n    if (path.charAt(0) !== \"/\") {\n        path = working + path;\n    }\n    path = fixPath(path);\n    return path;\n};\n\nconst resolvePath: Function = (path: string, identity: IIdentity, check?: boolean): string => {\n    check = check !== false;\n    path = path.trim();\n    if (path.charAt(0) === \"~\") {\n        path = path.replace(\"~\", \"/home/\" + identity.user + \"/\");\n    }\n    path = resolveWorkingPath(path, identity.workingDir);\n    if (check) {\n        dirAccessCheck(path, identity);\n    }\n    return path;\n};\n\nexport const resolveWorkingPaths: Function = (paths: string[], identitC: IIdentityContainer): Promise<string[]> => {\n    return Promise.resolve(paths.map(p => resolvePath(p, identitC.getIdentity(), false)));\n};\n\nconst resolveExecPaths: Function = (exec: string, identity: IIdentity): string[] => {\n    return [\n        resolvePath(exec, identity),\n        ...identity.getEnv(\"path\", \"/bin\").split(\";\").map(p => resolveWorkingPath(exec, p))\n    ];\n};\n\n\n\n\n\n// tslint:disable:no-bitwise\nconst doChmod: Function = (path: string, usr: number, grp: number, any: number) => {\n    let perms: number = 0;\n    perms |= (usr << bitOffsetUsr);\n    perms |= (grp << bitOffsetGrp);\n    perms |= (any << bitOffsetAny);\n    localStorage.setItem(permPath(path), \"0x\" + perms.toString(16));\n};\n// tslint:enable:no-bitwise\n\nexport const chmod: Function = (path: string, identitC: IIdentityContainer, hex: string) => {\n    try {\n        const identity: IIdentity = identitC.getIdentity();\n        path = resolvePath(path, identity);\n        fileExistsCheck(path);\n        if (typeof hex !== \"string\" || hex.length !== 3) {\n            throw new Error([\"FS Error\", \"\" + hex, \"must be 3 digits long\"].join(\" : \"));\n        }\n        const grp: number = parseInt(\"0x\" + hex.charAt(1), 16);\n        const usr: number = parseInt(\"0x\" + hex.charAt(0), 16);\n        const any: number = parseInt(\"0x\" + hex.charAt(2), 16);\n        if (identity.priveledged || getPathUsr(path) === identity.user) {\n            return Promise.resolve(doChmod(path, usr, grp, any));\n        }\n        throw new Error([\"FS ERROR\", path, \"Permissions can only be changed by root or owner\"].join(\" : \"));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nconst doChown: Function = (path: string, identity: IIdentity, user?: string, group?: string) => {\n    localStorage.setItem(owndPath(path), [user || identity.user, group || identity.user].join(\":\"));\n};\n\nexport const chown: Function = (path: string, identitC: IIdentityContainer, user?: string, group?: string) => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        dirExistsCheck(path);\n        if (identity.priveledged) {\n            return Promise.resolve(doChown(path, identity, user, group));\n        }\n        throw new Error([\"FS Error\", \"chown\", \"requires root\"].join(\" : \"));\n    } catch (e) {\n        Promise.reject(e);\n    }\n};\n\n\nconst doMkdir: Function = (path: string, identity: IIdentity): boolean => {\n    if (isDir(path)) {\n        return false;\n    }\n    localStorage.setItem(dirPath(path), dirString);\n    // tslint:disable-next-line:no-bitwise\n    doChmod(path, permBitRead | permBitWrit | permBitExec, permBitRead | permBitExec, permBitRead | permBitExec);\n    doChown(path, identity);\n    return true;\n};\n\nexport const mkdir: Function = (path: string, identitC: IIdentityContainer): Promise<boolean> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        if (isDir(path)) {\n            return Promise.resolve(false);\n        }\n        fileDirExistsCheck(path);\n        fileNotExistsCheck(path);\n        hasDirPermissionCheck(path, permBitWrit, identity);\n        return Promise.resolve(doMkdir(path, identity));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nconst doWrite: Function = (path: string, content: string, exists: boolean, identity: IIdentity) => {\n    exists = exists === true;\n    localStorage.setItem(filePath(path), content);\n    if (!exists) {\n        // tslint:disable-next-line:no-bitwise\n        doChmod(path, permBitRead | permBitWrit, permBitRead, permBitRead);\n        doChown(path, identity);\n    }\n    return [path, content];\n};\n\nexport const write: Function = (path: string, content: string, identitC: IIdentityContainer): Promise<string[]> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        const exists: boolean = doFileExists(path);\n        if (exists) {\n            hasPermissionCheck(path, permBitWrit, identity);\n        } else {\n            hasDirPermissionCheck(path, permBitWrit, identity);\n        }\n        return Promise.resolve(doWrite(path, content, exists, identity));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\nexport const touch: Function = (path: string, identitC: IIdentityContainer): Promise<string[]> => write(path, \"\", identitC);\n\nconst doRead: Function = (path: string): string | null => localStorage.getItem(filePath(path));\n\nexport const read: Function = (path: String, identitC: IIdentityContainer): Promise<string | null> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        fileExistsCheck(path);\n        hasPermissionCheck(path, permBitRead, identity);\n        return Promise.resolve(doRead(path));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nexport const append: Function = (path: string, newContent: string, identitC: IIdentityContainer): Promise<string[]> => {\n    return new Promise((resolve, reject) => {\n        read(path, identitC)\n            .then((content: string | null) => {\n                content = content || \"\";\n                content += newContent;\n                write(path, content, identitC)\n                    .then((wrt: string[]) => {\n                        resolve(wrt);\n                    }).catch((e: any) => {\n                        reject(e);\n                    });\n            })\n            .catch(() => {\n                write(path, newContent, identitC)\n                    .then((wrt: string[]) => {\n                        resolve(wrt);\n                    }).catch((e: any) => {\n                        reject(e);\n                    });\n            });\n    });\n};\n\nconst doDel: Function = (path: string): string => {\n    localStorage.removeItem(filePath(path));\n    localStorage.removeItem(permPath(path));\n    localStorage.removeItem(owndPath(path));\n    return path;\n};\n\nexport const del: Function = (path: string, identitC: IIdentityContainer): Promise<string> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        hasDirPermissionCheck(path, permBitWrit, identity);\n        fileExistsCheck(path);\n        return Promise.resolve(doDel(path));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\n\nconst doDelDir: Function = (path: string) => {\n    Object.keys(localStorage).forEach(p => {\n        const s: string = p.slice(4);\n        if (s.startsWith(path)) {\n            localStorage.removeItem(p);\n        }\n    });\n}\n\n\nexport const delDir: Function = (path: string, identitC: IIdentityContainer): Promise<string> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        hasDirPermissionCheck(path, permBitWrit, identity);\n        dirExistsCheck(path);\n        return Promise.resolve(doDelDir(path));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nconst getChildren: Function = (path: string): Array<IFSListEntrySpawn> => {\n    path = slashWrap(path);\n    let f: string = filePath(path);// + \"/\";\n    let d: string = dirPath(path);// + \"/\";\n    const l: number = path.split(\"/\").length;\n    console.log(f, d, l);\n    return Object.keys(localStorage)\n        .filter(p => p.startsWith(f) || p.startsWith(d))\n        .filter(p => p.split(\"/\").length <= l)\n        .map(p => {\n            const parts: string[] = p.split(\":\");\n            return { file: parts[0] === \"FSF\", path: parts[1] };\n        });\n};\n\ninterface IFSListEntrySpawn {\n    file: boolean;\n    path: string;\n}\n\nconst listEntry: Function = (rootPath: string, entry: IFSListEntrySpawn): IFSListEntry => {\n    const dir: boolean = !entry.file;\n    const path: string = entry.path;\n    const ownerData: string[] = getPathOwners(path);\n    const perms: number = getPermBits(path);\n    return {\n        full: path,\n        path: getFileDir(path),\n        name: rootPath === path ? \".\" : getFileName(path),\n        ext: !dir ? getFileExt(path) : \"\",\n        file: !dir,\n        user: ownerData[0],\n        group: ownerData[1],\n        permBytes: perms,\n        perms: (dir ? \"d\" : \"-\") + permString(perms),\n        size: dir ? 0 : new Blob([doRead(path)]).size,\n    };\n};\n\nexport const list: Function = (path: string, identitC: IIdentityContainer): Promise<IFSListEntry[]> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        console.log(\"LIST PATH RESOLVE\", path);\n        dirExistsCheck(path);\n        console.log(\"LIST DIR CHECK\", path);\n        hasPermissionCheck(path, permBitRead, identity);\n        let paths: Array<IFSListEntry> = getChildren(path);\n        console.log(\"LIST PATHS\", path, paths);\n        paths = paths.map((p: IFSListEntrySpawn) => listEntry(path, p));\n        paths = paths.sort((a: IFSListEntry, b: IFSListEntry) => a.full < b.full ? -1 : (a.full > b.full ? 1 : 0));\n        return Promise.resolve(paths);\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nexport interface IFSListEntry {\n    full: string;\n    path: string;\n    name: string;\n    ext: string;\n    file: boolean;\n    user: string;\n    group: string;\n    permBytes: number;\n    perms: string;\n    size: number;\n}\n\nexport const getExec: Function = (exec: string, identitC: IIdentityContainer): Promise<string> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        exec = cleanSlash(exec);\n        const paths: string[] = resolveExecPaths(exec, identity);\n        for (let i: number = 0; i < paths.length; i++) {\n            const path: string = paths[i];\n            if (doFileExists(path)) {\n                if (hasPermission(path, permBitExec, identity)) {\n                    return Promise.resolve(path);\n                }\n            }\n        }\n        throw new Error([\"FS Error\", exec, \"Not found\"].join(\" : \"));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nexport const execRead: Function = (exec: string, identitC: IIdentityContainer): Promise<[string, string]> => {\n    const identity: IIdentity = identitC.getIdentity();\n    return new Promise((resolve, reject) => {\n        getExec(exec, identity)\n            .then((path: string) => {\n                read(path, identity)\n                    .then((data: string) => resolve([path, data]))\n                    .catch((e: any) => reject(e));\n            })\n            .catch((e: any) => reject(e));\n    });\n};\n\n\n\nexport default {\n    read,\n    write,\n    del,\n    delDir,\n    list,\n    touch,\n    mkdir,\n    getExec,\n    execRead,\n    chmod,\n    chown,\n    resolveWorkingPaths,\n    append,\n    dirExists,\n    fileExists,\n};","import FS, { IFSListEntry } from \"../Services/FileSystem\";\n\n\nexport interface IIdentityContainer {\n    getIdentity(): IIdentity;\n}\n\nexport interface IIdentity extends IIdentityContainer {\n    user: string;\n    groups: string[];\n    workingDir: string;\n    priveledged: boolean;\n    getEnv(name: string, fallback?: string): string;\n    setEnv(name: string, value: string | string[]): void;\n    changeWorkingPath(path: string): Promise<boolean>;\n}\n\nexport default class Identity implements IIdentity {\n    user: string;\n    groups: string[];\n    workingDir: string;\n    priveledged: boolean;\n    env: { [s: string]: string } = {};\n\n    constructor(user: string, groups: Array<String>, workingDir: string) {\n        groups = groups || [];\n        workingDir = workingDir || \"/\";\n\n        this.user = user.toLowerCase();\n        this.groups = [...groups, this.user]\n            .filter((e, i, a) => a.indexOf(e) === i)\n            .map(e => e.toLowerCase());\n        this.workingDir = workingDir;\n        this.priveledged = this.user === \"root\";\n        this.setEnv(\"path\", [\"/bin\"]);\n    }\n\n    setEnv(name: string, value: string | string[]): void {\n        if (value instanceof Array) {\n            value = value.join(\";\");\n        }\n        this.env[name] = value;\n    }\n\n    getEnv(name: string, fallback?: string): string {\n        if (this.env.hasOwnProperty(name)) {\n            return this.env[name];\n        }\n        return fallback || \"\";\n    }\n\n    getIdentity(): IIdentity {\n        return this.clone();\n    }\n\n    setPriveledged(priveleged: boolean): void {\n        this.priveledged = priveleged;\n    }\n\n    async changeWorkingPath(path: string): Promise<boolean> {\n        try {\n            const exists: IFSListEntry[] = await FS.list(path, this);\n            if (exists instanceof Array) {\n                this.workingDir = path;\n                return Promise.resolve(true);\n            }\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return Promise.resolve(false);\n    }\n\n    clone(): Identity {\n        const ident: Identity = new Identity(this.user + \"\", [...this.groups], this.workingDir + \"\");\n        ident.setPriveledged(this.priveledged === true);\n        Object.entries(this.env).forEach((entry: [string, string]) => {\n            ident.setEnv(entry[0], entry[1]);\n        });\n        return ident;\n    }\n}","import { IProcessManager } from \"./ProcessManager\";\n\ninterface IQueuedDisplayItem {\n    text: any[];\n    over: number;\n}\n\nexport interface IDisplay {\n    init(pm: IProcessManager): void;\n    setText(text: string): Promise<any>;\n    output(data: any, over?: number, newLine?: boolean): Promise<any>;\n    info(): Promise<any>;\n}\n\nexport class StubDisplay implements IDisplay {\n    init(pm: IProcessManager): void {\n        console.log(\"STUB DISPLAY INIT\", pm);\n    }\n    setText(text: string): Promise<any> {\n        console.log(\"STUB DISPLAY SET TEXT\", text);\n        return Promise.resolve();\n    }\n    output(data: any, over?: number, newLine?: boolean): Promise<any> {\n        console.log(\"STUB DISPLAY OUTPUT\", data, over, newLine);\n        return Promise.resolve();\n    }\n    info(): Promise<any> {\n        console.log(\"STUB DISPLAY INFO\");\n        return Promise.resolve({});\n    }\n}\n\nexport default class Display implements IDisplay {\n    display: HTMLDivElement;\n    input: HTMLSpanElement;\n\n    queuedItems: IQueuedDisplayItem[] = [];\n\n    processManager: IProcessManager | null = null;\n\n    constructor() {\n        this.display = document.createElement(\"div\");\n        this.input = document.createElement(\"span\");\n    }\n\n    info(): Promise<any> {\n        return Promise.resolve({});\n    }\n\n    init(processManager: IProcessManager): void {\n        this.processManager = processManager;\n        this.createDisplay();\n        document.addEventListener(\"keydown\", () => {\n            if (document.activeElement !== this.input) {\n                this.input.focus();\n            }\n        });\n\n        this.input.addEventListener(\"keydown\", (ev: KeyboardEvent) => {\n            if (ev.ctrlKey && ev.key !== \"Control\" && !ev.repeat && ev.key !== \"F5\") {\n                this.controlKey(ev.key);\n            } else if ((ev.key === \"ArrowUp\" || ev.key === \"ArrowDown\") && !ev.repeat) {\n                this.history(ev.key === \"ArrowDown\" ? -1 : 1);\n            } else if (ev.key === \"Enter\") {\n                if (!ev.repeat) {\n                    this.enterText();\n                }\n            } else if (ev.key === \"Tab\") {\n                this.tabKey();\n                console.log(\"TAB KEY\");\n                ev.preventDefault();\n            } else {\n                return;\n            }\n            ev.preventDefault();\n        });\n        this.processQueue();\n    }\n\n    private colourizeText(text: string): HTMLElement[] {\n        const segments: string[] = text.split(/(?=§[0-9A-F]{6})/);\n        return segments.map((txt: string): HTMLElement => {\n            const span: HTMLSpanElement = document.createElement(\"span\");\n            if (txt.startsWith(\"§\")) {\n                const colours: String = txt.slice(0, 7);\n                span.setAttribute(\"style\", \"color:#\" + colours.slice(1, 4) + \";background-color:#\" + colours.slice(4, 7) + \";\");\n                txt = txt.slice(7);\n            }\n            span.textContent = txt;\n            return span;\n        });\n    }\n\n    private breakUptext(text: string): HTMLElement[] {\n        const elements: HTMLElement[] = [];\n\n        text.split(\"\\n\").forEach((t: string, index: number, array: string[]) => {\n            const span: HTMLSpanElement = document.createElement(\"span\");\n            this.colourizeText(t).forEach((e: HTMLElement) => {\n                span.append(e);\n            });\n            elements.push(span);\n            if (index < (array.length - 1)) {\n                elements.push(document.createElement(\"br\"));\n            }\n        });\n\n        return elements;\n    }\n\n\n    private writeToDisplay(text: any[], over?: number): void {\n        over = over || 0;\n        text.map((e) => {\n            this.display.insertBefore(e, this.input);\n        });\n    }\n\n    private reduceArrayForDisplay(data: Array<any>, level: number): string {\n        return data.reduce((out: string, inp: any, index: number) => {\n            const type: string = typeof inp;\n            if (type === \"string\" || type === \"number\") {\n                out += (index < 1 ? \"\" : \"\\t\") + inp;\n            } else {\n                if (inp instanceof Array) {\n                    out += (index < 1 ? \"\" : \"\\n\") + this.reduceArrayForDisplay(inp, level + 1);\n                }\n            }\n            return out;\n        }, \"\");\n    }\n\n    private processDisplayData(data: any): string {\n        if (data instanceof Array) {\n            return this.reduceArrayForDisplay(data, 0);\n        }\n        console.log(data);\n        return \"FAILED TO CONVERT FOR DISPLAY\";\n    }\n\n    output(data: any, over?: number, newLine?: boolean): Promise<any> {\n        newLine = newLine === true;\n        let text: string = \"\";\n        if (typeof data !== \"string\") {\n            text = this.processDisplayData(data);\n        } else {\n            text = data;\n        }\n        const items: HTMLElement[] = this.breakUptext(text);\n        if (newLine) {\n            items.push(document.createElement(\"br\"));\n        }\n        this.writeToDisplay(items, over);\n        this.scrollToBottom();\n        return Promise.resolve();\n    }\n\n    scrollToBottom() {\n        this.display.scrollTo(0, this.display.scrollHeight);\n    }\n\n    prompt(show: boolean): void {\n        console.log(\"PROMPT\", show);\n    }\n\n\n    private processQueue(): void {\n        this.queuedItems.map((item: IQueuedDisplayItem) => {\n            this.writeToDisplay(item.text, item.over);\n        });\n    }\n\n    private createDisplay(): void {\n        this.display.id = \"output\";\n        this.display.tabIndex = -1;\n        this.display.classList.add(\"output\");\n        this.input.id = \"input\";\n        this.input.classList.add(\"input\");\n        this.input.tabIndex = 0;\n        this.input.contentEditable = \"true\";\n        this.input.spellcheck = false;\n        const body: HTMLBodyElement | null = document.querySelector(\"body\");\n        if (body !== null) {\n            body.append(this.display);\n            this.display.append(this.input);\n        }\n    }\n\n    private history(dir: 1 | -1): void {\n        this.specialUserInput(\"DIR\", dir.toString());\n    }\n\n    private controlKey(key: string): void {\n        this.inputOutput(false);\n        this.specialUserInput(\"CTRL\", key);\n    }\n\n    public setText(text: string): Promise<any> {\n        this.input.textContent = text;\n        const range = document.createRange() || new Range();\n        var sel: Selection = window.getSelection() || new Selection();\n        const childs = this.input.childNodes;\n        console.log(\"DISPLAY\", childs[childs.length - 1]);\n        if (text.length > 0) {\n            range.setStart(childs[childs.length - 1], this.input.textContent.length);\n        } else {\n            range.setStart(this.input, this.input.textContent.length);\n        }\n        range.collapse(true);\n        sel.removeAllRanges();\n        sel.addRange(range);\n        this.input.focus();\n        this.scrollToBottom();\n        return Promise.resolve();\n        // const range = document.createRange();//Create a range (a range is a like the selection but invisible)\n        // range.selectNodeContents(contentEditableElement);//Select the entire contents of the element with the range\n        // range.collapse(false);//collapse the range to the end point. false means collapse to end rather than the start\n        // selection = window.getSelection();//get the selection object (allows you to change selection)\n        // selection.removeAllRanges();//remove any selections already made\n        // selection.addRange(range);\n    }\n\n    private enterText(): void {\n        const text: string = this.inputOutput();\n        if (text.length > 0) {\n            this.userInput(text);\n            this.setText(\"\");\n        }\n    }\n\n    private inputOutput(newLine?: boolean): string {\n        newLine = newLine !== false;\n        const text: string = this.input.textContent || \"\";\n        if (text.length > 0) {\n            this.output(text, 0, newLine);\n        }\n        return text;\n    }\n\n    private specialUserInput(type: string, text: string): void {\n        this.userInput(\"§§§\" + type + \"§§§\" + text);\n    }\n\n    private userInput(text: string): void {\n        if (this.processManager !== null) {\n            this.processManager.stdIn(\"user\", text);\n        }\n    }\n\n    private tabKey(): void {\n        this.specialUserInput(\"tab\", this.input.textContent || \"\");\n    }\n}","import FS, { createRoot } from \"./Services/FileSystem\";\nimport Identity from \"./Struct/Identity\";\nimport ProcessManager from \"./Services/ProcessManager\";\nimport Display from \"./Services/Display\";\nimport { DefaultApps } from \"./App/Default/index\";\n// import xTermDisplay from \"./Services/xTermDisplay\";\n\nconst rootIdent: Identity = new Identity(\"root\", [], \"/\");\nconst guestIdent: Identity = new Identity(\"guest\", [], \"/home/guest\");\n\nconst InIframe: Function = (): boolean => {\n    try {\n        return window.self !== window.top;\n    } catch (e) {\n        return true;\n    }\n};\n\nconst isRemote: boolean = InIframe();\n\ncreateRoot(rootIdent);\n\nFS.mkdir(\"/bin\", rootIdent);\n\nFS.mkdir(\"/home\", rootIdent);\n\n// guest home\nFS.mkdir(\"/home/guest\", rootIdent)\n    .then(() => {\n        FS.chown(\"/home/guest\", rootIdent, \"guest\", \"guest\")\n            .then(() => {\n                FS.mkdir(\"/home/guest/bin\", guestIdent);\n                // tslint:disable-next-line\n                FS.write(\"/home/guest/test\", \"Lorem ipsum dolor sit amet, consectetur \\n\\n\\n\\n\\n\\n\\n adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\", guestIdent);\n                FS.mkdir(\"/home/guest/bin\", guestIdent);\n            });\n    });\n\n// root home\nFS.mkdir(\"/home/root\", rootIdent);\n\nObject.entries(DefaultApps).map((app: Array<any>) => {\n    FS.write(\"bin/\" + app[0], app[1].toString().replace(\"class{\", \"class Main{\"), rootIdent);\n    FS.chmod(\"bin/\" + app[0].re, rootIdent, \"755\");\n});\n\n\nconst display: Display = new Display();\nconst processManager: ProcessManager = new ProcessManager();\n\n// const xTerm: xTermDisplay = new xTermDisplay();\n\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    console.log(location.host, isRemote);\n\n    display.init(processManager);\n    processManager.init(display);\n    // xTerm.init(processManager);\n\n    display.output([\n        [\"Welcome to wlf.io TSPseudoOS v0.1 LTNS(Little To No Support)\"],\n        [\"\"],\n        [\"  * Try the command help to see what you can do\"],\n        [\"\"],\n        [\"Last Login: Fri, 25 Oct 2019 18: 57: 47 GMT\"],\n    ], 0, true);\n\n    processManager.startProcess(\"bash\", [], guestIdent);\n});\n","import FS from \"./FileSystem\";\n// import Process from \"../Struct/Process\";\nimport Identity, { IIdentity } from \"../Struct/Identity\";\n// import { IDisplayItem, AppMessage, AppMessageType } from \"../App/libOS\";\nimport { IDisplay, StubDisplay } from \"./Display\";\nimport Process from \"../Struct/Process\";\n\ninterface IPendingApp {\n    args: Array<any>;\n    resolve: Function;\n    reject: Function;\n}\n\nexport interface IProcessManager {\n    display: IDisplay | null;\n    stdIn(source: string | number, data: any): void;\n    startProcess(exec: string, params: string[], identity: Identity | null, parent?: any): Promise<any>;\n    endProcess(pid: number): void;\n    getDisplay(): IDisplay;\n    setEnv(pid: number, name: string, value: string): Promise<any>;\n}\n\nexport default class ProcessManager implements IProcessManager {\n    display: IDisplay | null = null;\n    processes: { [s: number]: Process } = {};\n    pids: number = 0;\n    pending: IPendingApp[] = [];\n    libJS: string | null = null;\n\n    mainProcess: Process | null = null;\n\n    // constructor() {\n    // }\n\n    // OS: { [s: string]: { [s: string]: Function } } = {\n    //     FS: {\n    //         list: (process: Process, data: string) => FS.list(data, process),\n    //         mkdir: (process: Process, data: string) => FS.mkdir(data, process),\n    //         resolve: (process: Process, data: string[]) => FS.resolveWorkingPaths(data, process),\n    //         append: (process: Process, data: { path: string, content: string }) => FS.append(data.path, data.content, process),\n    //         write: (process: Process, data: { path: string, content: string }) => FS.write(data.path, data.content, process),\n    //         touch: (process: Process, path: string) => FS.touch(path, process),\n    //         read: (process: Process, path: string) => FS.read(path, process),\n    //         del: (process: Process, path: string) => FS.del(path, process),\n    //         dirExists: (process: Process, path: string) => FS.dirExists(path, process),\n    //         fileExists: (process: Process, path: string) => FS.fileExists(path, process),\n    //         delDir: (process: Process, path: string) => FS.delDir(path, process),\n    //     },\n    //     Process: {\n    //         end: (process: Process) => process.kill(),\n    //         setSelf: (process: Process, data: { prop: string, value: any }) => process.set(data.prop, data.value),\n    //         self: (process: Process) => Promise.resolve(process.data()),\n    //         start: (process: Process, data: any) => this.startProcess(data.exec, data.params, null, process),\n    //         crash: (process: Process, error: any) => { this.OS.Std.out(process, error); process.kill(); },\n    //         changeWorkingDir: (process: Process, data: any) => this.changeWorkingDir(data, process),\n    //     },\n    //     Std: {\n    //         out: (process: Process, data: any) =>\n    //             process.hasParent() ? process.intoParent(data) : this.OS.Out.print({ data: data, over: 0 }),\n    //         prompt: (process: Process, text: string) => {\n    //             if (this.mainProcess !== null && this.mainProcess.id === process.id && this.display !== null) {\n    //                 this.display.setText(text);\n    //             }\n    //         },\n    //         in: (process: Process, data: any) => process.intoChild(data.pid, data.data, data.source || null),\n    //     },\n    //     Out: {\n    //         print: (item: IDisplayItem) => this.output(item.data, item.over, false),\n    //         printLn: (item: IDisplayItem) => { console.log(item); return this.output(item.data, item.over, true); },\n    //     },\n    //     Display: {\n    //         info: () => this.display !== null ? this.display.info() : Promise.reject(new Error(\"PM Error : missing display : ...\")),\n    //     },\n    //     Remote: {\n    //         connect: (process: Process, address: string) => this.log(process.identifier(), [\"Remote\", \"connect\"], address),\n    //         disconnect: (process: Process, id: number) => this.log(process.identifier(), [\"Remote\", \"disconnect\"], id),\n    //         in: (process: Process, data: any) => this.log(process.identifier(), [\"Remote\", \"stdIn\"], data),\n    //     }\n    // };\n\n    setEnv(pid: number, name: string, value: string): Promise<any> {\n        if (this.processes.hasOwnProperty(pid)) {\n            this.processes[pid].setEnv(name, value);\n            return Promise.resolve();\n        }\n        return Promise.reject();\n    }\n\n    init(display: IDisplay): void {\n        this.display = display;\n    }\n\n    killProcess(processID: number): void {\n        const process: Process | null = this.getProcessFromID(processID);\n        if (process !== null) {\n            process.kill();\n        }\n    }\n\n    stdIn(source: string | number, data: any): void {\n        if (this.mainProcess !== null) {\n            this.mainProcess.stdIn(source, data);\n        } else {\n            console.log(\"STDIN\", data);\n        }\n    }\n\n    endProcess(pid: number) {\n        if (this.processes.hasOwnProperty(pid)) {\n            delete this.processes[pid];\n        }\n    }\n\n    async startProcess(exec: string, params: string[], identity: IIdentity | null, parent?: Process): Promise<any> {\n        if (!(identity instanceof Identity)) {\n            if (parent instanceof Process) {\n                identity = parent.getIdentity();\n            }\n        }\n\n        if (!(identity instanceof Identity)) {\n            throw new Error(\"Identity is not identity\");\n        }\n\n        params = params.filter(s => s.length > 0);\n\n        try {\n            const execData: [string, string] = await FS.execRead(exec, identity);\n            this.pids++;\n            const execPath: string = execData[0];\n            const code: string = execData[1].trim();\n            const proc: Process = new Process(this, execPath, this.pids, params, identity, parent);\n            proc.start(code);\n\n            this.processes[this.pids] = proc;\n\n            if (this.mainProcess === null) {\n                this.mainProcess = proc;\n            }\n            return proc;\n        } catch (e) {\n            console.log([\"Process Error\", e]);\n            return Promise.reject([\"Process Error\", e]);\n        }\n    }\n\n    private getProcessFromID(id: number): Process | null {\n        return Object.values(this.processes).find(p => p.id === id) || null;\n    }\n\n    getDisplay(): IDisplay {\n        if (this.display !== null) {\n            return this.display;\n        }\n        return new StubDisplay();\n    }\n\n}","import { IProcessManager } from \"../Services/ProcessManager\";\nimport FS from \"../Services/FileSystem\";\nimport { FunctionSignature, IDisplayItem } from \"../App/libOS\";\nimport { OSApi } from \"./Types\";\nimport Identity, { IIdentityContainer, IIdentity } from \"./Identity\";\nimport OSLib from \"./OSLib\";\n\n\nexport interface IProcess {\n    id: number;\n    exec: string;\n    params: string[];\n    identity: IIdentity;\n    // parent: IProcess | null;\n    dead: boolean;\n    parentID: number;\n}\n\nexport default class Process implements IProcess, IIdentityContainer {\n    manager: IProcessManager;\n    lib: OSLib;\n    code: string = \"\";\n\n    id: number;\n    identity: IIdentity;\n    params: string[];\n    exec: string;\n    dead: boolean = false;\n    children: { [s: number]: Process } = [];\n    app: any;\n\n    parentInCB: Function | null = null;\n    parentEndCB: Function | null = null;\n    parentID: number = -1;\n\n    private api: OSApi = {\n        Std: {\n            out: (data: any) => this.hasParent() ? this.intoParent(data) : this.api.Display.print({ data: data, over: 0 }),\n            in: (data: any) => this.intoChild(data.pid, data.data, data.source || null),\n        },\n        FS: {\n            list: (data: string) => FS.list(data, this),\n            mkdir: (data: string) => FS.mkdir(data, this),\n            resolve: (data: string[]) => FS.resolveWorkingPaths(data, this),\n            append: (data: { path: string, content: string }) => FS.append(data.path, data.content, this),\n            write: (data: { path: string, content: string }) => FS.write(data.path, data.content, this),\n            touch: (path: string) => FS.touch(path, this),\n            read: (path: string) => FS.read(path, this),\n            del: (path: string) => FS.del(path, this),\n            dirExists: (path: string) => FS.dirExists(path, this),\n            fileExists: (path: string) => FS.fileExists(path, this),\n            delDir: (path: string) => FS.delDir(path, this),\n        },\n        Process: {\n            end: () => this.kill(),\n            setEnv: (data: { prop: string, value: any, pid?: number }) => this.setEnv(data.prop, data.value, data.pid),\n            self: () => Promise.resolve(this.data()),\n            start: (data: any) => this.manager.startProcess(data.exec, data.params, null, this),\n            crash: (error: any) => { this.api.Std.out(error); return this.kill(); },\n            changeWorkingPath: (data: { path: string, pid: number }) => this.changeWorkingPath(data.path, data.pid),\n        },\n        Display: {\n            prompt: (text: string) => this.manager.getDisplay().setText(text),\n            print: (item: IDisplayItem) => this.manager.getDisplay().output(item.data, item.over, false),\n            printLn: (item: IDisplayItem) => this.manager.getDisplay().output(item.data, item.over, true),\n            info: () => this.manager.getDisplay().info(),\n        }\n    };\n\n    getIdentity(): IIdentity {\n        if (this.identity instanceof Identity) {\n            return this.identity.getIdentity();\n        } else {\n            return this.identity;\n        }\n    }\n\n    constructor(manager: IProcessManager, exec: string, pid: number, params: string[], identitC: IIdentity, parent?: Process) {\n        this.manager = manager;\n        //this.display = display;\n        this.exec = exec;\n        this.id = pid;\n        this.lib = new OSLib((signature: FunctionSignature, data: any) => this.call(signature, data));\n        this.identity = identitC.getIdentity();\n        this.params = params;\n        if (parent instanceof Process) {\n            this.parentID = parent.id;\n            const cbs: [Function, Function] = parent.registerChild(this);\n            this.parentInCB = cbs[0];\n            this.parentEndCB = cbs[1];\n        }\n    }\n\n    setEnv(prop: string, value: any, pid?: number): Promise<any> {\n        if (typeof pid === \"number\") {\n            if (pid === this.parentID || this.children.hasOwnProperty(pid)) {\n                return this.manager.setEnv(pid, prop, value);\n            } else {\n                return Promise.reject();\n            }\n        } else {\n            switch (prop) {\n                case \"log\":\n                    console.log(\"Process SET\", value);\n                    break;\n                case \"workingPath\":\n                case \"workingDir\":\n                    this.changeWorkingPath(value);\n                    break;\n                default:\n                    this.identity.setEnv(prop, value);\n                    break;\n            }\n            this.event([\"Process\", \"self\"], this.data());\n            return Promise.resolve();\n        }\n    }\n\n    start(code: string): boolean {\n        this.code = code;\n        const wrapper: string = [\n            \"((proc,osLib)=>{\\n\",\n            this.code,\n            \";\\nreturn new Main(proc,osLib);\\n})\"\n        ].join(\"\");\n\n        // tslint:disable: no-eval\n        this.app = eval(wrapper)(this.data(), this.lib);\n        // tslint:enable: no-eval\n        return true;\n    }\n\n    hasParent(): boolean {\n        return this.parentID >= 0;\n    }\n\n    private intoParent(data: any): Promise<any> {\n        if (this.parentInCB !== null) {\n            this.parentInCB(data);\n            return Promise.resolve();\n        }\n        return Promise.reject();\n    }\n\n    call(signature: FunctionSignature, data: any): Promise<any> {\n        if (this.api.hasOwnProperty(signature.service)) {\n            if (this.api[signature.service].hasOwnProperty(signature.func)) {\n                return this.api[signature.service][signature.func](data);\n            }\n        }\n        return Promise.reject(\n            new Error([\n                \"PM Error\",\n                \"Atempt to access non-existant System Call\\n\" + signature.service + \">\" + signature.func,\n                this.exec + \"[\" + this.id + \"]\"\n            ].join(\" : \"))\n        );\n    }\n\n    data(): IProcess {\n        return {\n            id: this.id,\n            exec: this.exec,\n            params: [... this.params],\n            identity: this.identity,\n            dead: this.dead,\n            parentID: this.parentID,\n        };\n    }\n\n    registerChild(process: Process): [Function, Function] {\n        this.children[process.id] = process;\n        return [\n            (data: any) => {\n                this.stdIn(process.id, data);\n            },\n            () => { this.removeChild(process); }\n        ];\n    }\n\n    removeChild(process: Process): void {\n        this.event([\"Process\", \"end\"], process.id);\n        delete this.children[process.id];\n    }\n\n    intoChild(pid: number, source: number | string, data: any): Promise<any> {\n        if (this.children.hasOwnProperty(pid)) {\n            return this.children[pid].stdIn(source, data);\n        }\n        return Promise.reject();\n    }\n\n    stdIn(source: number | string, data: any): Promise<any> {\n        return this.event([\"Std\", \"in\"], { from: source, data });\n    }\n\n    async changeWorkingPath(path: string, pid?: number): Promise<any> {\n        if (typeof pid === \"number\" && pid > 0) {\n            this.manager.setEnv(pid, \"workingPath\", path);\n        } else {\n            this.identity.changeWorkingPath(path);\n        }\n    }\n\n    event(type: [string, string], data: any): Promise<any> {\n        return this.lib.fireEvent({ service: type[0], func: type[1] }, data);\n    }\n\n    kill(): Promise<any> {\n        this.dead = true;\n        delete this.app;\n        delete this.lib;\n        if (this.parentEndCB !== null) {\n            this.parentEndCB();\n        }\n        this.manager.endProcess(this.id);\n        return Promise.resolve();\n    }\n}\n\n","import { ILibOS, ILibStd, ILibFS, IStdInMsg, ILibProcess, ILibDisplay, ILibUtil } from \"../App/libOS\";\nimport { FunctionSignature, PromiseHolder } from \"./Types\";\nimport { IProcess } from \"./Process\";\nimport Util from \"./Util\";\nimport CMD, { ILibCMD } from \"../Services/Cmd\";\n\nexport default class OSLib implements ILibOS {\n\n    private _call: (signature: FunctionSignature, data: any) => Promise<any>;\n    private hooks: { [s: string]: Function } = {};\n    private awaitProcs: { [s: number]: PromiseHolder } = {};\n\n    Std: ILibStd = {\n        event: {\n            in: (cb: (msg: IStdInMsg) => void) => this.hookEvent(\"Std\", \"in\", cb),\n        },\n        out: (data: any) => this.call(\"Std\", \"out\", data),\n        in: (pid: number, data: any, source?: string | number) => this.call(\"Std\", \"in\", { pid, data, source }),\n    };\n    FS: ILibFS = {\n        list: (path: string) => this.call(\"FS\", \"list\", path),\n        mkdir: (path: string) => this.call(\"FS\", \"mkdir\", path),\n        resolve: (paths: string[]) => this.call(\"FS\", \"resolve\", paths),\n        append: (path: string, content: string) => this.call(\"FS\", \"append\", { path, content }),\n        write: (path: string, content: string) => this.call(\"FS\", \"write\", { path, content }),\n        touch: (path: string) => this.call(\"FS\", \"touch\", path),\n        read: (path: string) => this.call(\"FS\", \"read\", path),\n        del: (path: string) => this.call(\"FS\", \"del\", path),\n        dirExists: (path: string) => this.call(\"FS\", \"dirExists\", path),\n        fileExists: (path: string) => this.call(\"FS\", \"fileExists\", path),\n        delDir: (path: string) => this.call(\"FS\", \"delDir\", path),\n    };\n    Process: ILibProcess = {\n        event: {\n            start: (cb: Function) => this.hookEvent(\"Process\", \"start\", cb),\n            msg: (cb: Function) => this.hookEvent(\"Process\", \"msg\", cb),\n            end: (cb: Function) => this.hookEvent(\"Process\", \"end\", cb),\n            self: (cb: Function) => this.hookEvent(\"Process\", \"self\", cb),\n        },\n        end: () => this.call(\"Process\", \"end\"),\n        //setSelf: (prop: string, value: any) => this.call(\"Process\", \"setSelf\", { prop, value }),\n        self: () => this.call(\"Process\", \"self\"),\n        start: (exec: string, params: string[]) => this.call(\"Process\", \"start\", { exec, params }),\n        crash: (error: any) => this.call(\"Process\", \"crash\", error),\n        changeWorkingPath: (path: string, pid?: number) => this.call(\"Process\", \"changeWorkingPath\", { path, pid }),\n        msg: (pid: number, msg: any) => this.call(\"Process\", \"msg\", { pid, msg }),\n        kill: (pid: number) => this.call(\"Process\", \"kill\", pid),\n        list: () => this.call(\"Process\", \"list\"),\n        startAndAwaitOutput: (exec: string, params: string[]) => this.startAndAwait(exec, params),\n    };\n    Display: ILibDisplay = {\n        prompt: (text: string) => this.call(\"Display\", \"prompt\", text),\n        printRaw: (data: string | String[] | Array<string[]>, over: number, newLine: boolean) => this.call(\"Display\", \"print\", { data: data, over: over || 0, newLine: newLine === true }),\n        print: (data: string | String[] | Array<string[]>, over?: number) => this.Display.printRaw(data, over, false),\n        printLn: (data: string | String[] | Array<string[]>, over?: number) => this.Display.printRaw(data, over, true),\n        info: () => this.call(\"Display\", \"info\"),\n    };\n\n    Util: ILibUtil = Util;\n\n    CMD: ILibCMD = CMD;\n\n    constructor(call: (signature: FunctionSignature, data: any) => Promise<any>) {\n        this._call = call;\n    }\n\n    private call(service: string, func: string, data?: any): Promise<any> {\n        return this._call({ service: service, func: func }, data);\n    }\n\n    private hookEvent(service: string, func: string, cb: Function): void {\n        const event: string = service + \":\" + func;\n        this.hooks[event] = cb;\n    }\n\n    private startAndAwait(exec: string, params: string[]): Promise<any> {\n        return new Promise((resolve, reject) => {\n            this.Process.start(exec, params)\n                .then((proc: IProcess) => {\n                    this.awaitProcs[proc.id] = {\n                        resolve: resolve,\n                        reject: reject,\n                    };\n                })\n                .catch(e => reject(e));\n        });\n    }\n\n    fireEvent(signature: FunctionSignature, data: any): Promise<any> {\n        return this.fireHooks(signature, data);\n    }\n\n    private awaitIn(msg: IStdInMsg): boolean {\n        if (typeof msg.from === \"number\" && this.awaitProcs.hasOwnProperty(msg.from)) {\n            this.awaitProcs[msg.from].resolve(msg);\n            delete this.awaitProcs[msg.from];\n            return true;\n        }\n        return false;\n    }\n\n    private fireHooks(signature: FunctionSignature, data: any): Promise<any> {\n        const event: string = signature.service + \":\" + signature.func;\n        if (event === \"Std:in\") {\n            if (this.awaitIn(data)) {\n                return Promise.resolve();\n            }\n        }\n        if (this.hooks.hasOwnProperty(event)) {\n            return this.hooks[event](data);\n        }\n        return Promise.reject(\"MISSING\")\n    }\n}","import { ILibUtil } from \"../App/libOS\";\n\nexport const Util: ILibUtil = {\n    loadArgs: (args, opts, map): Promise<string[]> => {\n        let remain: string[] = [];\n        for (let i: number = 0; i < args.length; i++) {\n            let arg: any = args[i];\n            if (arg.startsWith(\"--\") && arg.length > 2) {\n                arg = arg.slice(2);\n                if (opts.hasOwnProperty(arg)) {\n                    if (i < args.length - 1 && !args[i + 1].startsWith(\"-\") && typeof opts[arg] !== \"boolean\") {\n                        i++;\n                        opts[arg] = args[i];\n                    } else {\n                        opts[arg] = !opts[arg];\n                    }\n                } else {\n                    return Promise.reject(\n                        new Error(\n                            [\"Load Args Error\",\n                                \"unrecognized option '--\" + arg + \"'\\nTry '--help' for more information.\",\n                                JSON.stringify(args)\n                            ].join(\" : \"))\n                    );\n                }\n            } else if (arg.startsWith(\"-\") && arg.length > 1 && arg !== \"--\") {\n                arg = arg.slice(1);\n                for (let j = 0; j < arg.length; j++) {\n                    const shrt: string = arg.charAt(j);\n                    if (map.hasOwnProperty(shrt)) {\n                        opts[map[shrt]] = !opts[map[shrt]];\n                    }\n                }\n            } else {\n                remain = [...remain, arg];\n            }\n        }\n        return Promise.resolve(remain);\n    },\n    bytesToHuman: (bytes, kibi, bits) => {\n        kibi = kibi === true;\n        bits = bits === true;\n        if (bits) bytes *= 8;\n        const step = kibi ? 1000 : 1024;\n        const set =\n            bits ?\n                (kibi ? [\"b\", \"kb\", \"mb\", \"gb\", \"pb\"] : [\"b\", \"Kb\", \"Mb\", \"Gb\", \"Pb\"])\n                :\n                (kibi ? [\"B\", \"kB\", \"mB\", \"gB\", \"pB\"] : [\"B\", \"KB\", \"MB\", \"GB\", \"PB\"])\n            ;\n        let o = 0;\n\n        while (bytes > step) {\n            bytes /= step;\n            o++;\n        }\n        return Math.round(bytes) + set[o];\n    }\n};\n\nexport default Util;","import { ILibCMD } from \"./Cmd\";\n\nexport interface ILibCMD {\n    Colours: ILibCMDColours;\n    Colourize(text: string, fore: string, back?: string): string;\n}\n\nexport interface ILibCMDColours {\n    red: \"F00\";\n    green: \"0F0\";\n    blue: \"23F\";\n    black: \"000\";\n    white: \"FFF\";\n    lightBlue: \"38F\";\n}\n\nconst testColourHex: Function = (text: string): boolean => {\n    const re: RegExp = /[0-9A-F]{3}/g;\n    return re.test(text);\n};\n\nconst hexCheck: Function = (text: string, name: string): void => {\n    if (!testColourHex(text)) {\n        throw new Error([\"CMD Error\", name, \"Must be 3 hex chars\"].join(\" : \"));\n    }\n};\n\nconst CMD: ILibCMD = {\n    Colours: {\n        red: \"F00\",\n        green: \"0F0\",\n        blue: \"23F\",\n        black: \"000\",\n        white: \"FFF\",\n        lightBlue: \"38F\",\n    },\n    Colourize: (text: string, fore: string, back?: string) => {\n        back = back || \"000\";\n        back = back.toUpperCase();\n        fore = fore.toUpperCase();\n        hexCheck(fore);\n        hexCheck(back);\n        return \"§\" + fore + back + text;\n    }\n};\n\nexport default CMD;","import ls from \"./ls\";\nimport bash from \"./bash\";\nimport mkdir from \"./mkdir\";\nimport cat from \"./cat\";\nimport touch from \"./touch\";\nimport rm from \"./rm\";\nimport cd from \"./cd\";\nimport tail from \"./tail\";\nimport head from \"./head\";\nimport edit from \"./edit\";\n\nexport const DefaultApps: { [s: string]: Function } = {\n    ls,\n    bash,\n    mkdir,\n    cat,\n    touch,\n    rm,\n    cd,\n    tail,\n    head,\n    edit,\n};","import { IFSListEntry } from \"../../Services/FileSystem\";\nimport { ILibOS, AppOpts, AppOptsMap } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\n\nexport default class Main {\n    opts: AppOpts = {\n        all: false,\n        human: false,\n        long: false,\n        \"no-group\": false,\n        raw: false,\n    };\n    count: number = 0;\n    done: number = 0;\n\n    argMap: AppOptsMap = {\n        a: \"all\",\n        h: \"human\",\n        l: \"long\",\n        G: \"no-group\",\n    };\n\n    process: IProcess;\n    api: ILibOS;\n\n    constructor(process: IProcess, OS: ILibOS) {\n        this.process = process;\n        this.api = OS;\n        this.start(process.params);\n    }\n\n    async start(data: string[]) {\n        try {\n            let paths = await this.api.Util.loadArgs(data, this.opts, this.argMap);\n            this.count = paths.length;\n            if (this.count < 1) {\n                paths = [\"\"];\n                this.count = 1;\n            }\n            paths.map(s => this.list(s));\n        } catch (e) {\n            this.error(e);\n        }\n\n    }\n\n    formatFileName(entry: IFSListEntry): string {\n        let name: string = entry.name;\n        if (this.opts.raw) {\n            return name;\n        }\n        if (name.indexOf(\" \") >= 0) {\n            name = \"'\" + name + \"'\"\n        }\n        let fore: string = this.api.CMD.Colours.white;\n        let back: string = this.api.CMD.Colours.black;\n        if (!entry.file) {\n            fore = this.api.CMD.Colours.blue;\n        }\n        return this.api.CMD.Colourize(name, fore, back);\n    };\n\n    longOutputEntry(entry: IFSListEntry): any[] {\n        const out: { [s: string]: any } = {\n            perms: entry.perms,\n            user: entry.user,\n            group: entry.group,\n            size: entry.size,\n            name: this.formatFileName(entry),\n        };\n        if (this.opts[\"no-group\"]) {\n            delete out.group;\n        }\n        return Object.values(out);\n    };\n\n    longOutput(path: string, data: Array<IFSListEntry>): any[] {\n        let arr: Array<string[] | string> = [\n            path,\n            [\"perms\\t\", \"user\", this.opts[\"no-group\"] ? \"\" : \"group\", \"size\", \"name\"].filter(c => c.length > 0)\n        ];\n        data.map(d => this.longOutputEntry(d)).map(e => arr.push(e));\n        return arr;\n    }\n\n    shortOutput(data: Array<IFSListEntry>): string[] {\n        return data.map(e => this.formatFileName(e));\n    }\n\n    output(path: string, data: Array<IFSListEntry>) {\n        if (!this.opts.all) {\n            data = data.filter(d => !d.name.startsWith(\".\"));\n        }\n        if (this.opts.human) {\n            // todo : Human Sizes\n            // data.forEach(d => {\n            //     d.size = OS.Util.bytesToHuman(d.size);\n            // });\n        }\n        let result: string[] | Array<string[]>;\n        result = this.opts.long ? this.longOutput(path, data) : this.shortOutput(data);\n\n        this.api.Std.out(result);\n\n        this.done++;\n        if (this.done >= this.count) {\n            this.api.Process.end();\n        }\n    }\n\n    error(e: any) {\n        this.api.Process.crash(e);\n    }\n\n    async list(path: string) {\n        try {\n            const data: IFSListEntry[] = await this.api.FS.list(path);\n            this.output(path, data);\n        } catch (e) {\n            console.log(\"bob\", e);\n            this.error(e);\n        }\n    }\n}","import { ILibOS, IStdInMsg } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\nexport default class Main {\n    bashHistoryFile: string = \"~/.bash_history\";\n\n    bashProcess: IProcess;\n\n    host: string = window.location.origin.split(\"://\")[1].split(\":\")[0] || \"[MISSING HOST]\";\n    activeProcessID: number = -1;\n    activeOutputed: boolean = false;\n\n    subProcs: { [s: number]: IProcess } = {};\n\n    history: string[] = [];\n    historyPosition: number = 0;\n\n    api: ILibOS;\n\n    constructor(process: IProcess, OS: ILibOS) {\n        this.bashProcess = process;\n        this.api = OS;\n        this.api.Process.event.self((proc: IProcess) => this.selfUpdate(proc));\n        this.api.Process.event.end((pid: number): Promise<any> => this.end(pid));\n        this.api.Std.event.in((data: IStdInMsg) => this.stdIn(data));\n        this.start();\n    }\n\n    setHistoryPosition(pos: number): void {\n        this.historyPosition = Math.min(Math.max(pos, 0), history.length);\n    }\n\n    showHistory(pos: number): void {\n        this.setHistoryPosition(pos);\n        this.api.Display.prompt(this.history[this.history.length - this.historyPosition]);\n    }\n\n    newHistory(input: string) {\n        if (input.length > 0 && input !== this.history[this.history.length - 1]) {\n            this.history.push(input);\n            this.api.FS.append(this.bashHistoryFile, input + \"\\n\");\n        }\n        this.historyPosition = 0;\n    }\n\n    getSubProc(pid: number): IProcess | null {\n        if (this.subProcs.hasOwnProperty(pid)) {\n            return this.subProcs[pid];\n        }\n        return null;\n    }\n\n    printPrompt(newLine?: boolean): void {\n        newLine = newLine === true;\n        this.api.Std.out(\n            (newLine ? \"\\n\" : \"\")\n            +\n            this.api.CMD.Colourize(this.bashProcess.identity.user + \"@\" + this.host, this.api.CMD.Colours.green)\n            +\n            this.api.CMD.Colourize(\":\", this.api.CMD.Colours.white)\n            +\n            this.api.CMD.Colourize(this.bashProcess.identity.workingDir.replace(\"/home/\" + this.bashProcess.identity.user, \"~\"), this.api.CMD.Colours.blue)\n            +\n            this.api.CMD.Colourize(\"$ \", this.api.CMD.Colours.white)\n        );\n    }\n\n    splitUserInput(text: string): string[] {\n        const parts = text.match(/(\".*?\"|[^\" \\s]+)(?=\\s* |\\s*$)/g) || [];\n        return parts.map(s => {\n            s = s.trim();\n            if (s.charAt(0) === '\"' && s.charAt(s.length - 1) === '\"') {\n                s = s.slice(1, s.length - 1);\n            }\n            return s;\n        });\n    }\n\n    start() {\n        this.api.FS.read(this.bashHistoryFile)\n            .then((content: string) => {\n                this.history = content.split(\"\\n\")\n                    .filter(s => s.length > 0)\n                    .filter((s, i, a) => i > 0 && a[i - 1] !== s);\n            });\n        this.printPrompt();\n    }\n\n    resolveAppIn(msg: IStdInMsg): Promise<any> {\n        const proc: IProcess | null = this.getSubProc(parseInt(msg.from));\n        let output: any = msg.data;\n        if (msg.data instanceof Array && proc !== null) {\n            if (msg.data[0] === \"ERROR\") {\n                output = proc.exec.split(\"/\").pop() + \": \" + msg.data[2];\n            }\n        }\n        if (parseInt(msg.from, 10) === this.activeProcessID) {\n            this.activeOutputed = true;\n        }\n        this.api.Std.out(output);\n        return Promise.resolve(\"asd\");\n    }\n\n    ctrlCode(type: string): void {\n        switch (type) {\n            case \"c\":\n                this.api.Std.out(\"^C\");\n                this.printPrompt(true);\n                this.api.Display.prompt(\"\");\n                break;\n        }\n    }\n\n    async tabComplete(text: string) {\n        const parts = this.splitUserInput(text);\n        let prompt: any = null\n        if (parts.length === 1) {\n\n        } else {\n            const part = parts[parts.length - 1];\n            const dirs = part.split(\"/\");\n            const dir = dirs.slice(0, dirs.length - 1).join(\"/\");\n            const t = dirs[dirs.length - 1];\n            const args = [\"--raw\"];\n            if (t.startsWith(\".\")) {\n                args.push(\"--all\");\n            }\n            args.push(dir);\n            const ls = await this.api.Process.startAndAwaitOutput(\"ls\", args);\n            const opts = ls.data;\n            const result = opts.filter((e: string) => e.startsWith(t));\n            if (result.length === 1) {\n                dirs[dirs.length - 1] = result[0];\n                const d = dirs.join(\"/\");\n                const isDir = await this.api.FS.dirExists(d);\n                parts[parts.length - 1] = d + (isDir ? \"/\" : \"\");\n            } else {\n                prompt = opts;\n            }\n        }\n        if (prompt !== null) {\n            this.api.Std.out(text + \"\\n\");\n            this.api.Std.out(prompt);\n            this.printPrompt(true);\n        }\n        this.api.Display.prompt(parts.map((s: string) => s.indexOf(\" \") >= 0 ? '\"' + s + '\"' : s).join(\" \"));\n\n    }\n\n    specialCode(code: string): void {\n        const parts: string[] = code.split(\"§§§\").filter(s => s.length > 0);\n        switch (parts[0].toLowerCase()) {\n            case \"ctrl\":\n                this.ctrlCode(parts[1]);\n                break;\n            case \"dir\":\n                this.showHistory(parseInt(parts[1], 10) + this.historyPosition);\n                break;\n            case \"tab\":\n                this.tabComplete(parts[1]);\n                break;\n            default:\n                console.log(\"SPECIAL CODE\", parts);\n                break;\n        }\n    }\n\n    selfUpdate(data: IProcess): Promise<any> {\n        this.bashProcess = data;\n        return Promise.resolve();\n    }\n\n    async stdIn(data: IStdInMsg) {\n        if (data.from === \"user\") {\n            if (typeof data.data === \"string\") {\n                if (data.data.startsWith(\"§§§\")) {\n                    this.specialCode(data.data);\n                } else {\n                    if (this.activeProcessID > 0) {\n                        this.api.Std.in(this.activeProcessID, data.data, data.from);\n                        return;\n                    }\n                    if (data.data === \"exit\") {\n                        this.api.Process.end();\n                        return;\n                    }\n                    const parts: string[] = this.splitUserInput(data.data);\n                    const exec: string = parts.shift() || \"\";\n                    try {\n                        const proc = await this.api.Process.start(exec, parts);\n                        this.activeOutputed = false;\n                        this.subProcs[proc.id] = proc;\n                        this.activeProcessID = proc.id;\n                    } catch (e) {\n                        console.log(\"EXEC ERROR\", e);\n                        try {\n                            if (e[1] === \"FS Error\" && e[3] === \"Not found\") {\n                                this.api.Std.out(exec + \": command not found\");\n                            } else {\n                                this.api.Std.out(e[1]);\n                            }\n                        } catch (er) {\n                            this.api.Std.out([\"BASH LAUNCH ERROR\", er.message]);\n                        }\n                        this.printPrompt(true);\n                    }\n                    this.newHistory(data.data);\n                }\n            }\n        } else {\n            const resolve = await this.resolveAppIn(data);\n            if (typeof resolve !== \"string\") {\n                console.log(resolve);\n            }\n        }\n    }\n    end(pid: number): Promise<any> {\n        const sub: IProcess | null = this.getSubProc(pid);\n        if (sub !== null) {\n            delete this.subProcs[pid];\n            if (pid === this.activeProcessID) {\n                this.activeProcessID = -1;\n                this.printPrompt(this.activeOutputed);\n            }\n        }\n        return Promise.resolve();\n    }\n}","import { ILibOS } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\nexport default class Main {\n\n    help: string[][] = [\n        [\"Usage: mkdir[OPTION]...DIRECTORY...\"],\n        [\"Create the DIRECTORY(ies), if they do not already exist.\"],\n        [\"\"],\n        [\"Mandatory arguments to long options are mandatory for short options too.\"],\n        //        [\"  - m, --mode= MODE\", \"set file mode(as in chmod), not a = rwx - umask\"],\n        [\"  - p, --parents\", \"no error if existing, make parent directories as needed\"],\n        [\"  - v, --verbose\", \"print a message for each created directory\"],\n        //        [\"  - Z\", \"\", \"\", \"set SELinux security context of each created directory\"],\n        //        [\"  \", \"\", \"\", \"to the default type\"],\n        [\"  \", \"--help\", \"\", \"display this help and exit\"],\n        [\"  \", \"--version\", \"output version information and exit\"],\n    ];\n\n    version: string = [\n        \"mkdir (GNU coreutils) 0.1\",\n        \"Copyright(C) 2010 wlf.io.\",\n        \"License MIT License < https://raw.githubusercontent.com/wlfio/TSPseudoOS/master/LICENSE >.\",\n        \"This is free software: you are free to change and redistribute it.\",\n        \"There is NO WARRANTY, to the extent permitted by law.\",\n        \"\",\n        \"Written by wlf.io.\"\n    ].join(\"\\n\");\n\n    options: { [s: string]: any } = {\n        help: false,\n        version: false,\n        verbose: false,\n        parents: false,\n    };\n    optMap: { [s: string]: string } = {\n        \"?\": \"help\",\n        v: \"verbose\",\n        p: \"parents\"\n    };\n\n    count: number = 0;\n    OS: ILibOS;\n\n    constructor(process: IProcess, OS: ILibOS) {\n        this.OS = OS;\n        this.start(process.params);\n    }\n\n    error(e: any) {\n        if (e instanceof Array) {\n            if (e[2] === \"Path is not directory\") {\n                e = new Error(\"MKDIR ERROR : no such file or directory '\" + e[3] + \"' : \" + e.join(\" : \"));\n            }\n        }\n        this.OS.Process.crash(e);\n    }\n\n    breakPathIntoParentPaths(path: string): string[] {\n        const parts: string[] = path.split(\"/\").filter(s => s.length > 0);\n        return parts.reduce((out: string[], inp: string, i: number) => {\n            if (i === 0) {\n                inp = \"/\" + inp;\n            } else {\n                inp = out[out.length - 1] + \"/\" + inp;\n            }\n            out.push(inp);\n            return out;\n        }, []);\n    }\n\n    breakPathsIntoParentPaths(paths: string[]): Array<string[]> {\n        return paths.map((path: string) => {\n            if (this.options.parents) {\n                return this.breakPathIntoParentPaths(path);\n            }\n            return [path];\n        });\n    }\n\n    async make(rawPaths: string[]): Promise<any> {\n        let prefix: string = \"\";\n        try {\n            const paths: string[] = await this.OS.FS.resolve(rawPaths);\n            console.log(\"PATHS\", paths);\n            const broken: string[][] = this.breakPathsIntoParentPaths(paths);\n            console.log(\"BROKEN\", broken);\n            for (let j: number = 0; j < broken.length; j++) {\n                const set: string[] = broken[j];\n                for (let i: number = 0; i < set.length; i++) {\n                    const path: string = set[i];\n                    const done: boolean = await this.OS.FS.mkdir(path);\n                    console.log(\"PATH DONE\", path, done);\n                    if (this.options.verbose && done) {\n                        this.OS.Std.out(prefix + \"created directory '\" + set[this.count] + \"'\");\n                    }\n                    if (!done && (!this.options.parents)) {\n                        this.OS.Std.out(prefix + \"cannot create directory '\" + set[this.count] + \"': File exists\");\n                    }\n                    prefix = \"\\n\";\n                }\n            }\n            this.OS.Process.end();\n        } catch (e) {\n            console.log(\"ERROROR\", e);\n            this.error(e);\n        }\n    }\n\n    async start(args: string[]) {\n        const params: string[] = await this.OS.Util.loadArgs(args, this.options, this.optMap);\n        if (params.length < 1 && !this.options.help && !this.options.version) {\n            this.OS.Process.crash(\n                new Error([\n                    \"mkdir error\",\n                    \"missing operand\\nTry 'mkdir --help' for more information\"\n                    , JSON.stringify(args)].join(\" : \")\n                )\n            );\n            return;\n        }\n        if (this.options.help) {\n            this.OS.Std.out(this.help);\n        } else if (this.options.version) {\n            this.OS.Std.out(this.version);\n        } else {\n            this.make(params);\n        }\n    };\n}","import { ILibOS, AppOptsMap, AppOpts } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\n\nexport default class Main {\n    options: AppOpts = {\n        number: false,\n        \"squeeze-blank\": false,\n    };\n\n    optMap: AppOptsMap = {\n        n: \"number\",\n        s: \"squeeze-blank\",\n    };\n\n    count: number = 0;\n\n    OS: ILibOS;\n\n    constructor(process: IProcess, OS: ILibOS) {\n        this.OS = OS;\n        this.start(process.params);\n    }\n\n    error(e: any) {\n        this.OS.Process.crash(e);\n    }\n\n    splitLines(content: string): string[][] {\n        const lines: string[][] = [];\n        let empty: boolean = false;\n        content.split(\"\\n\").forEach((txt: string) => {\n            this.count++;\n            if (txt.length < 1) {\n                if (empty) {\n                    return;\n                }\n                empty = true;\n            } else {\n                empty = false;\n            }\n            const line: string[] = [];\n            if (this.options.number) {\n                line.push(this.count.toString());\n            }\n            line.push(txt);\n            lines.push(line);\n        });\n        return lines;\n    }\n\n    output(content: string) {\n        this.OS.Std.out(this.splitLines(content));\n    }\n\n    async cat(paths: string[]): Promise<any> {\n        try {\n            for (let i: number = 0; i < paths.length; i++) {\n                const content: string | null = await this.OS.FS.read(paths[i]);\n                this.output(content);\n            }\n            this.OS.Process.end();\n        } catch (e) {\n            this.error(e);\n        }\n    }\n\n    async start(data: string[]) {\n        try {\n            const paths = await this.OS.Util.loadArgs(data, this.options, this.optMap);\n\n            if (paths.length < 1) {\n                throw new Error(\"CAT ERROR : you must include file path(s) : \" + JSON.stringify(data));\n            }\n            this.cat(paths);\n        } catch (e) {\n            console.log(\"CAT ERROR\", e);\n            this.error(e);\n        }\n    }\n}","import { ILibOS, AppOpts, AppOptsMap } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\nconst touch: Function = (process: IProcess, OS: ILibOS) => {\n\n    class Touch {\n        options: AppOpts = {\n            verbose: false,\n        };\n        optMap: AppOptsMap = {\n            v: \"verbose\",\n        }\n        constructor(params: string[]) {\n            this.loadArgs(params);\n        }\n        firstOut: boolean = true;\n\n        async loadArgs(params: string[]) {\n            try {\n                const paths = await OS.Util.loadArgs(params, this.options, this.optMap);\n                this.run(paths);\n            } catch (e) {\n                this.error(e);\n            }\n        }\n\n        error(e: any): void {\n            OS.Process.crash(e);\n        }\n\n        async run(paths: string[]) {\n            for (let i: number = 0; i < paths.length; i++) {\n                const out = await OS.FS.touch(paths[i]);\n                this.printOutput(out);\n            }\n            OS.Process.end();\n        }\n\n        printOutput(out: any): void {\n            if (this.options.verbose) {\n                OS.Std.out((this.firstOut ? \"\" : \"\\n\") + \"created '\" + out[0] + \"'\");\n                this.firstOut = false;\n            }\n        }\n    }\n\n    new Touch(process.params);\n};\n\nexport default touch;","import { ILibOS, AppOpts, AppOptsMap } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\nexport default class Main {\n    options: AppOpts = {\n        verbose: false,\n        recursive: false,\n    };\n    optMap: AppOptsMap = {\n        v: \"verbose\",\n        r: \"recursive\",\n    }\n    OS: ILibOS;\n\n    constructor(process: IProcess, OS: ILibOS) {\n        this.OS = OS;\n        this.loadArgs(process.params);\n    }\n    firstOut: boolean = true;\n\n    async loadArgs(params: string[]) {\n        try {\n            const paths = await this.OS.Util.loadArgs(params, this.options, this.optMap);\n            this.run(paths);\n        } catch (e) {\n            this.error(e);\n        }\n    }\n\n    error(e: any): void {\n        this.OS.Process.crash(e);\n    }\n\n    async run(paths: string[]) {\n        try {\n            paths = await this.OS.FS.resolve(paths);\n            for (let i: number = 0; i < paths.length; i++) {\n                const path = paths[i];\n                const dir = await this.OS.FS.dirExists(path);\n                let out;\n                if (dir) {\n                    if (!this.options.recursive) {\n                        this.printDirError(path);\n                    } else {\n                        out = await this.OS.FS.delDir(path);\n                    }\n                } else {\n                    out = await this.OS.FS.del(path);\n                }\n                //const ls = await this.OS.FS.list(paths[i]);\n                //console.log(ls);\n                this.printOutput(out);\n            }\n            this.OS.Process.end();\n        } catch (e) {\n            this.error(e);\n        }\n    }\n\n    printOutput(out: any): void {\n        if (this.options.verbose) {\n            this.output(\"deleted '\" + out[0] + \"'\");\n        }\n    }\n\n    printDirError(path: string): void {\n        this.output(\"cannot remove '\" + path + \"' it's a directory\");\n    }\n\n    output(text: string) {\n        this.OS.Std.out((this.firstOut ? \"\" : \"\\n\") + \"rm: \" + text);\n        this.firstOut = false;\n    }\n}","import { ILibOS, AppOpts, AppOptsMap } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\nexport default class Main {\n    private api: ILibOS;\n    private proc: IProcess;\n    options: AppOpts = {\n    };\n    optMap: AppOptsMap = {\n    }\n    constructor(process: IProcess, OS: ILibOS) {\n        this.api = OS;\n        this.proc = process;\n        this.loadArgs(process.params);\n    }\n    firstOut: boolean = true;\n\n    async loadArgs(params: string[]) {\n        try {\n            const paths = await this.api.Util.loadArgs(params, this.options, this.optMap);\n            this.run(paths);\n        } catch (e) {\n            this.error(e);\n        }\n    }\n\n    error(e: any): void {\n        this.api.Process.crash(e);\n    }\n\n    async run(paths: string[]) {\n        try {\n            if (this.proc.parentID > 0) {\n                paths = await this.api.FS.resolve(paths);\n                const result = await this.api.Process.changeWorkingPath(paths[0], this.proc.parentID);\n                console.log(\"CHANGE DIR\", paths, result);\n            }\n            //console.log(PROCESS, paths);\n            this.api.Process.end();\n        } catch (e) {\n            this.error(e);\n        }\n    }\n};","import { ILibOS, AppOptsMap, AppOpts } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\n\ndeclare var OS: ILibOS;\ndeclare var PROCESS: IProcess;\n\n\nconst tail: Function = () => {\n    class Tail {\n        options: AppOpts = {\n            follow: false,\n        };\n\n        optMap: AppOptsMap = {\n            f: \"follow\",\n        };\n\n        files: { [s: string]: string | null } = {};\n\n        constructor(process: IProcess) {\n            this.loadArgs(process.params);\n        }\n\n        error(e: any) {\n            OS.Process.crash(e);\n        }\n\n        async loadArgs(params: string[]) {\n            const paths = await OS.Util.loadArgs(params, this.options, this.options);\n            try {\n                await this.run(paths)\n            } catch (e) {\n                this.error(e);\n            }\n            console.log(paths);\n            OS.Process.end();\n        }\n\n        async run(paths: string[]) {\n\n            this.files = await this.readFiles(paths);\n\n            console.log(this.files);\n            if (this.options.follow) {\n\n            } else {\n                OS.Process.end();\n            }\n        }\n\n        async readFiles(paths: string[]) {\n            const files: { [s: string]: string | null } = {};\n            for (let i = 0; i < paths.length; i++) {\n                const path = paths[i];\n                files[path] = await OS.FS.read(path);\n            }\n            return files;\n        }\n    }\n\n    new Tail(PROCESS);\n};\n\nexport default tail;","export default class Main {\n    str: string;\n    constructor(str: string) {\n        this.str = str;\n    }\n}","export default class Main {\n    bob: number = 1;\n}"],"sourceRoot":""}