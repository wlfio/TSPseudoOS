{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/Services/FileSystem.ts","webpack:///./src/Struct/Identity.ts","webpack:///./src/Struct/Process.ts","webpack:///./src/Struct/Util.ts","webpack:///./src/Struct/OSLib.ts","webpack:///./src/Services/Display.ts","webpack:///./src/App/Default/index.ts","webpack:///./src/App/Default/ls.ts","webpack:///./src/App/Default/bash.ts","webpack:///./src/App/Default/mkdir.ts","webpack:///./src/App/Default/cat.ts","webpack:///./src/App/Default/touch.ts","webpack:///./src/App/Default/rm.ts","webpack:///./src/App/Default/cd.ts","webpack:///./src/App/Default/tail.ts","webpack:///./src/App/Default/head.ts","webpack:///./src/App/Default/edit.ts","webpack:///./src/app.ts","webpack:///./src/Services/ProcessManager.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","fixPath","path","split","reduce","out","inp","length","slice","join","filePath","indexOf","dirPath","permPath","owndPath","getPathOwners","localStorage","getItem","getPathOwnerString","getPathUsr","getPermBits","parseInt","permStringPart","action","ps","permString","perms","getPermBitsUsr","getPermBitsGrp","getPermBitsAny","groupHasPermission","identity","groups","includes","getPathGrp","hasPermission","user","priveledged","userHasPermission","anyHasPermission","getFileName","pop","getFileExt","parts","isDir","createRoot","doMkdir","isDirCheck","console","trace","Error","getFileDir","hasPermissionCheck","hasDirPermissionCheck","dirExistsCheck","doFileExists","fileExistsCheck","resolveWorkingPath","working","charAt","slashWrap","trim","resolvePath","check","replace","workingDir","dirAccessCheck","doChmod","usr","grp","any","setItem","toString","doChown","group","permBitRead","write","content","identitC","getIdentity","exists","Promise","resolve","doWrite","e","reject","doRead","read","getExec","exec","paths","getEnv","map","resolveExecPaths","str","cleanSlash","del","removeItem","doDel","delDir","keys","forEach","startsWith","doDelDir","list","f","filter","file","getChildren","entry","dir","ownerData","full","ext","permBytes","size","Blob","listEntry","sort","a","b","touch","mkdir","fileDirExistsCheck","fileNotExistsCheck","execRead","then","data","catch","chmod","hex","chown","resolveWorkingPaths","append","newContent","wrt","dirExists","fileExists","identC","Identity","env","this","toLowerCase","setEnv","Array","fallback","clone","priveleged","ident","setPriveledged","entries","Process","manager","pid","params","parent","code","dead","children","parentInCB","parentEndCB","parentID","api","Std","hasParent","intoParent","Display","print","over","in","intoChild","source","FS","end","kill","prop","self","start","startProcess","crash","error","changeWorkingPath","prompt","text","getDisplay","setText","item","output","printLn","info","id","lib","signature","cbs","registerChild","log","event","wrapper","app","eval","service","func","process","stdIn","removeChild","from","type","fireEvent","loadArgs","args","opts","remain","arg","JSON","stringify","j","shrt","bytesToHuman","bytes","kibi","bits","step","set","Math","round","hooks","awaitProcs","cb","hookEvent","msg","startAndAwaitOutput","startAndAwait","printRaw","newLine","Util","_call","proc","fireHooks","awaitIn","StubDisplay","pm","DefaultApps","ls","all","human","long","raw","count","done","argMap","h","G","formatFileName","fore","CMD","Colours","white","back","black","blue","Colourize","longOutput","arr","values","longOutputEntry","push","result","shortOutput","OS","async","PROCESS","bash","bashHistoryFile","host","window","location","origin","activeProcessID","activeOutputed","subProcs","history","historyPosition","bashProcess","selfUpdate","pos","min","max","setHistoryPosition","input","green","match","printPrompt","getSubProc","splitUserInput","dirs","ctrlCode","showHistory","tabComplete","specialCode","shift","er","message","newHistory","resolveAppIn","help","version","options","verbose","parents","optMap","v","make","rawPaths","prefix","broken","breakPathIntoParentPaths","breakPathsIntoParentPaths","cat","number","lines","empty","txt","line","splitLines","firstOut","run","printOutput","rm","recursive","printDirError","cd","tail","follow","files","readFiles","head","edit","bob","rootIdent","guestIdent","isRemote","top","InIframe","display","queuedItems","processManager","document","createElement","createDisplay","addEventListener","activeElement","focus","ev","ctrlKey","repeat","controlKey","enterText","tabKey","preventDefault","processQueue","span","colours","setAttribute","textContent","elements","index","array","colourizeText","insertBefore","level","reduceArrayForDisplay","processDisplayData","items","breakUptext","writeToDisplay","show","tabIndex","contentEditable","spellcheck","body","querySelector","specialUserInput","inputOutput","range","createRange","Range","sel","getSelection","Selection","childs","childNodes","setStart","collapse","removeAllRanges","addRange","userInput","processes","pids","pending","libJS","mainProcess","processID","getProcessFromID","execData","execPath","find","init"],"mappings":"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","file":"os.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","import { IIdentity, IIdentityContainer } from \"../Struct/Identity\";\n\nconst dirString: string = \"___dir___\";\n\nconst cleanSlash: Function = (str: string) => str.replace(/\\//g, \"\");\n\nconst slashWrap: Function = (path: string): string => {\n    if (path.charAt(0) !== \"/\") {\n        path = \"/\" + path;\n    }\n    if (path.charAt(path.length - 1) !== \"/\") {\n        path += \"/\";\n    }\n    return path;\n};\n\nconst fixPath: Function = (path: string) => {\n    return \"/\" + path.split(\"/\").reduce((out: string[], inp: string) => {\n        if (inp.length > 0 && inp !== \".\") {\n            if (inp === \"..\") {\n                return out.slice(0, out.length - 1);\n            } else {\n                return [...out, inp];\n            }\n        }\n        return out;\n    }, []).join(\"/\");\n};\n\nconst filePath: Function = (path: string) => path.indexOf(\"FSF:\") !== 0 ? \"FSF:\" + fixPath(path) : path;\nconst dirPath: Function = (path: string) => path.indexOf(\"FSD:\") !== 0 ? \"FSD:\" + fixPath(path) : path;\nconst permPath: Function = (path: string) => path.indexOf(\"FSP:\") !== 0 ? \"FSP:\" + fixPath(path) : path;\nconst owndPath: Function = (path: string) => path.indexOf(\"FSO:\") !== 0 ? \"FSO:\" + fixPath(path) : path;\n\n\nconst getPathOwnerString: Function = (path: string): string => localStorage.getItem(owndPath(path)) || \"nobody:nobody\";\nconst getPathOwners: Function = (path: string): string[] => getPathOwnerString(path).split(\":\");\nconst getPathUsr: Function = (path: string) => getPathOwners(path)[0];\nconst getPathGrp: Function = (path: string) => getPathOwners(path)[1];\n\n\nconst permBitRead: number = 4;\nconst permBitWrit: number = 2;\nconst permBitExec: number = 1;\n\nconst bitOffsetUsr: number = 8;\nconst bitOffsetAny: number = 0;\nconst bitOffsetGrp: number = 4;\n\nconst getPermBits: Function = (path: string): number => parseInt(localStorage.getItem(permPath(path)) || \"\", 16);\n\n// tslint:disable: no-bitwise\n\nconst permStringPart: Function = (action: number): string => {\n    let ps: string = \"\";\n    ps += (action & permBitRead) ? \"r\" : \"-\";\n    ps += (action & permBitWrit) ? \"w\" : \"-\";\n    ps += (action & permBitExec) ? \"x\" : \"-\";\n    return ps;\n};\n\nconst permString: Function = (perms: number): string => {\n    return permStringPart(perms >> bitOffsetUsr)\n        + permStringPart(perms >> bitOffsetGrp)\n        + permStringPart(perms >> bitOffsetAny);\n};\n\nconst getPermBitsUsr: Function = (path: string): number => getPermBits(path) >> bitOffsetUsr;\nconst getPermBitsGrp: Function = (path: string): number => getPermBits(path) >> bitOffsetGrp;\nconst getPermBitsAny: Function = (path: string): number => getPermBits(path) >> bitOffsetAny;\n\nconst userHasPermission: Function = (path: string, action: number, identity: IIdentity) => {\n    const user: string = identity.user;\n    if (identity.priveledged) {\n        if (action & permBitExec) {\n            return (\n                (getPermBitsUsr(path) & permBitExec)\n                ||\n                (getPermBitsGrp(path) & permBitExec)\n                ||\n                (getPermBitsAny(path) & permBitExec)\n            );\n        }\n        return true;\n    }\n    if (user === getPathUsr(path) && getPermBitsUsr(path) & action) {\n        return true;\n    }\n    return false;\n};\n\nconst groupHasPermission: Function = (path: string, action: number, identity: IIdentity) => {\n    const groups: string[] = identity.groups;\n    if (groups.includes(getPathGrp(path)) && getPermBitsGrp(path) & action) {\n        return true;\n    }\n    return false;\n};\n\nconst anyHasPermission: Function = (path: string, action: number): boolean => {\n    if (getPermBitsAny(path) & action) {\n        return true;\n    }\n    return false;\n};\n// tslint:enable: no-bitwise\n\n\nconst hasPermission: Function = (path: string, action: number, identity: number) => {\n    return (\n        userHasPermission(path, action, identity)\n        ||\n        groupHasPermission(path, action, identity)\n        ||\n        anyHasPermission(path, action)\n    );\n};\n\n\nconst getFileName: Function = (path: string): string => path.split(\"/\").pop() || \"\";\n\nconst getFileExt: Function = (path: string): string => {\n    const parts: string[] = getFileName(path).split(\".\");\n    return parts.length > 1 ? parts.pop() || \"\" : \"\";\n};\n\nconst isDir: Function = (path: string) => {\n    if (path.length < 1 || path === \"/\") {\n        path = \"/\";\n    }\n    return localStorage.getItem(dirPath(path)) === dirString;\n};\n\nexport const createRoot: Function = (identity: IIdentity): void => {\n    doMkdir(\"/\", identity);\n}\n\nconst isDirCheck: Function = (path: string) => {\n    if (!isDir(path)) {\n        console.trace();\n        throw new Error([\"Access Error\", \"Path is not directory\", path].join(\" : \"));\n    }\n};\n\nconst getFileDir: Function = (path: string): string => {\n    const parts: string[] = path.split(\"/\");\n    path = parts.slice(0, parts.length - 1).join(\"/\");\n    return path;\n};\n\n\nconst hasPermissionCheck: Function = (path: string, action: number, identity: IIdentity) => {\n    if (!hasPermission(path, action, identity)) {\n        throw new Error([\"Permissions Error\", \"Denied \" + permStringPart(action), path].join(\" : \"));\n    }\n};\nconst hasDirPermissionCheck: Function = (path: number, action: number, identity: number) =>\n    hasPermissionCheck(getFileDir(path), action, identity);\n\nconst dirAccessCheck: Function = (path: string, identity: IIdentity) => {\n    path = getFileDir(path);\n    const parts: string[] = path.split(\"/\");\n    for (let i: number = 2; i <= parts.length; i++) {\n        const p: string = parts.slice(0, i).join(\"/\");\n        isDirCheck(p);\n        hasPermissionCheck(p, permBitExec, identity);\n    }\n};\n\n\n\nconst dirExistsCheck: Function = (path: string) => {\n    if (!isDir(path)) {\n        throw new Error([\"Access Error\", \"Cannot access '\" + path + \"': No such file or directory\", path].join(\" : \"));\n    }\n};\n\nconst doFileExists: Function = (path: string): boolean => {\n    return localStorage.getItem(filePath(path)) !== null;\n};\n\nexport const fileExists: Function = (path: string, identC: IIdentityContainer) => {\n    const identity: IIdentity = identC.getIdentity();\n    path = resolvePath(path, identity);\n    return Promise.resolve(doFileExists(path));\n}\n\nconst fileDirExistsCheck: Function = (path: string): void => {\n    path = getFileDir(path);\n    isDirCheck(path);\n};\n\n\nconst fileExistsCheck: Function = (path: string) => {\n    if (!doFileExists(path)) {\n        throw new Error([\"Access Error\", \"Cannot access '\" + path + \"': No such file\", path].join(\" : \"));\n    }\n};\n\nconst fileNotExistsCheck: Function = (path: string) => {\n    if (doFileExists(path)) {\n        throw new Error([\"Access Error\", \"Path exists\", path].join(\" : \"));\n    }\n};\n\nexport const dirExists: Function = (path: string, identitC: IIdentityContainer) => {\n    const identity: IIdentity = identitC.getIdentity();\n    path = resolvePath(path, identity);\n    return Promise.resolve(isDir(path));\n};\n\nconst resolveWorkingPath: Function = (path: string, working: string): string => {\n    working = slashWrap(working || \"/\");\n    path = path.trim();\n    if (path.charAt(0) !== \"/\") {\n        path = working + path;\n    }\n    path = fixPath(path);\n    return path;\n};\n\nconst resolvePath: Function = (path: string, identity: IIdentity, check?: boolean): string => {\n    check = check !== false;\n    path = path.trim();\n    if (path.charAt(0) === \"~\") {\n        path = path.replace(\"~\", \"/home/\" + identity.user + \"/\");\n    }\n    path = resolveWorkingPath(path, identity.workingDir);\n    if (check) {\n        dirAccessCheck(path, identity);\n    }\n    return path;\n};\n\nexport const resolveWorkingPaths: Function = (paths: string[], identitC: IIdentityContainer): Promise<string[]> => {\n    return Promise.resolve(paths.map(p => resolvePath(p, identitC.getIdentity(), false)));\n};\n\nconst resolveExecPaths: Function = (exec: string, identity: IIdentity): string[] => {\n    return [\n        resolvePath(exec, identity),\n        ...identity.getEnv(\"path\", \"/bin\").split(\";\").map(p => resolveWorkingPath(exec, p))\n    ];\n};\n\n\n\n\n\n// tslint:disable:no-bitwise\nconst doChmod: Function = (path: string, usr: number, grp: number, any: number) => {\n    let perms: number = 0;\n    perms |= (usr << bitOffsetUsr);\n    perms |= (grp << bitOffsetGrp);\n    perms |= (any << bitOffsetAny);\n    localStorage.setItem(permPath(path), \"0x\" + perms.toString(16));\n};\n// tslint:enable:no-bitwise\n\nexport const chmod: Function = (path: string, identitC: IIdentityContainer, hex: string) => {\n    try {\n        const identity: IIdentity = identitC.getIdentity();\n        path = resolvePath(path, identity);\n        fileExistsCheck(path);\n        if (typeof hex !== \"string\" || hex.length !== 3) {\n            throw new Error([\"FS Error\", \"\" + hex, \"must be 3 digits long\"].join(\" : \"));\n        }\n        const grp: number = parseInt(\"0x\" + hex.charAt(1), 16);\n        const usr: number = parseInt(\"0x\" + hex.charAt(0), 16);\n        const any: number = parseInt(\"0x\" + hex.charAt(2), 16);\n        if (identity.priveledged || getPathUsr(path) === identity.user) {\n            return Promise.resolve(doChmod(path, usr, grp, any));\n        }\n        throw new Error([\"FS ERROR\", path, \"Permissions can only be changed by root or owner\"].join(\" : \"));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nconst doChown: Function = (path: string, identity: IIdentity, user?: string, group?: string) => {\n    localStorage.setItem(owndPath(path), [user || identity.user, group || identity.user].join(\":\"));\n};\n\nexport const chown: Function = (path: string, identitC: IIdentityContainer, user?: string, group?: string) => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        dirExistsCheck(path);\n        if (identity.priveledged) {\n            return Promise.resolve(doChown(path, identity, user, group));\n        }\n        throw new Error([\"FS Error\", \"chown\", \"requires root\"].join(\" : \"));\n    } catch (e) {\n        Promise.reject(e);\n    }\n};\n\n\nconst doMkdir: Function = (path: string, identity: IIdentity): boolean => {\n    if (isDir(path)) {\n        return false;\n    }\n    localStorage.setItem(dirPath(path), dirString);\n    // tslint:disable-next-line:no-bitwise\n    doChmod(path, permBitRead | permBitWrit | permBitExec, permBitRead | permBitExec, permBitRead | permBitExec);\n    doChown(path, identity);\n    return true;\n};\n\nexport const mkdir: Function = (path: string, identitC: IIdentityContainer): Promise<boolean> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        if (isDir(path)) {\n            return Promise.resolve(false);\n        }\n        fileDirExistsCheck(path);\n        fileNotExistsCheck(path);\n        hasDirPermissionCheck(path, permBitWrit, identity);\n        return Promise.resolve(doMkdir(path, identity));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nconst doWrite: Function = (path: string, content: string, exists: boolean, identity: IIdentity) => {\n    exists = exists === true;\n    localStorage.setItem(filePath(path), content);\n    if (!exists) {\n        // tslint:disable-next-line:no-bitwise\n        doChmod(path, permBitRead | permBitWrit, permBitRead, permBitRead);\n        doChown(path, identity);\n    }\n    return [path, content];\n};\n\nexport const write: Function = (path: string, content: string, identitC: IIdentityContainer): Promise<string[]> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        const exists: boolean = doFileExists(path);\n        if (exists) {\n            hasPermissionCheck(path, permBitWrit, identity);\n        } else {\n            hasDirPermissionCheck(path, permBitWrit, identity);\n        }\n        return Promise.resolve(doWrite(path, content, exists, identity));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\nexport const touch: Function = (path: string, identitC: IIdentityContainer): Promise<string[]> => write(path, \"\", identitC);\n\nconst doRead: Function = (path: string): string | null => localStorage.getItem(filePath(path));\n\nexport const read: Function = (path: String, identitC: IIdentityContainer): Promise<string | null> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        fileExistsCheck(path);\n        hasPermissionCheck(path, permBitRead, identity);\n        return Promise.resolve(doRead(path));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nexport const append: Function = (path: string, newContent: string, identitC: IIdentityContainer): Promise<string[]> => {\n    return new Promise((resolve, reject) => {\n        read(path, identitC)\n            .then((content: string | null) => {\n                content = content || \"\";\n                content += newContent;\n                write(path, content, identitC)\n                    .then((wrt: string[]) => {\n                        resolve(wrt);\n                    }).catch((e: any) => {\n                        reject(e);\n                    });\n            })\n            .catch(() => {\n                write(path, newContent, identitC)\n                    .then((wrt: string[]) => {\n                        resolve(wrt);\n                    }).catch((e: any) => {\n                        reject(e);\n                    });\n            });\n    });\n};\n\nconst doDel: Function = (path: string): string => {\n    localStorage.removeItem(filePath(path));\n    localStorage.removeItem(permPath(path));\n    localStorage.removeItem(owndPath(path));\n    return path;\n};\n\nexport const del: Function = (path: string, identitC: IIdentityContainer): Promise<string> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        hasDirPermissionCheck(path, permBitWrit, identity);\n        fileExistsCheck(path);\n        return Promise.resolve(doDel(path));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\n\nconst doDelDir: Function = (path: string) => {\n    Object.keys(localStorage).forEach(p => {\n        const s: string = p.slice(4);\n        if (s.startsWith(path)) {\n            localStorage.removeItem(p);\n        }\n    });\n}\n\n\nexport const delDir: Function = (path: string, identitC: IIdentityContainer): Promise<string> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        hasDirPermissionCheck(path, permBitWrit, identity);\n        dirExistsCheck(path);\n        return Promise.resolve(doDelDir(path));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nconst getChildren: Function = (path: string): Array<IFSListEntrySpawn> => {\n    const f: string = filePath(path) + \"/\";\n    const d: string = dirPath(path) + \"/\";\n    const l: number = path.split(\"/\").length;\n    return Object.keys(localStorage)\n        .filter(p => p.startsWith(f) || p.startsWith(d))\n        .filter(p => p.split(\"/\").length <= l + 1)\n        .map(p => {\n            const parts: string[] = p.split(\":\");\n            return { file: parts[0] === \"FSF\", path: parts[1] };\n        });\n};\n\ninterface IFSListEntrySpawn {\n    file: boolean;\n    path: string;\n}\n\nconst listEntry: Function = (entry: IFSListEntrySpawn): IFSListEntry => {\n    const dir: boolean = !entry.file;\n    const path: string = entry.path;\n    const ownerData: string[] = getPathOwners(path);\n    const perms: number = getPermBits(path);\n    return {\n        full: path,\n        path: getFileDir(path),\n        name: getFileName(path),\n        ext: !dir ? getFileExt(path) : \"\",\n        file: !dir,\n        user: ownerData[0],\n        group: ownerData[1],\n        permBytes: perms,\n        perms: (dir ? \"d\" : \"-\") + permString(perms),\n        size: dir ? 0 : new Blob([doRead(path)]).size,\n    };\n};\n\nexport const list: Function = (path: string, identitC: IIdentityContainer): Promise<IFSListEntry[]> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        dirExistsCheck(path);\n        hasPermissionCheck(path, permBitRead, identity);\n        const paths: Array<IFSListEntry> = getChildren(path)\n            .map((p: IFSListEntrySpawn) => listEntry(p))\n            .sort((a: IFSListEntry, b: IFSListEntry) => a.full < b.full ? -1 : (a.full > b.full ? 1 : 0));\n        return Promise.resolve(paths);\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nexport interface IFSListEntry {\n    full: string;\n    path: string;\n    name: string;\n    ext: string;\n    file: boolean;\n    user: string;\n    group: string;\n    permBytes: number;\n    perms: string;\n    size: number;\n}\n\nexport const getExec: Function = (exec: string, identitC: IIdentityContainer): Promise<string> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        exec = cleanSlash(exec);\n        const paths: string[] = resolveExecPaths(exec, identity);\n        for (let i: number = 0; i < paths.length; i++) {\n            const path: string = paths[i];\n            if (doFileExists(path)) {\n                if (hasPermission(path, permBitExec, identity)) {\n                    return Promise.resolve(path);\n                }\n            }\n        }\n        throw new Error([\"FS Error\", exec, \"Not found\"].join(\" : \"));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nexport const execRead: Function = (exec: string, identitC: IIdentityContainer): Promise<[string, string]> => {\n    const identity: IIdentity = identitC.getIdentity();\n    return new Promise((resolve, reject) => {\n        getExec(exec, identity)\n            .then((path: string) => {\n                read(path, identity)\n                    .then((data: string) => resolve([path, data]))\n                    .catch((e: any) => reject(e));\n            })\n            .catch((e: any) => reject(e));\n    });\n};\n\n\n\nexport default {\n    read,\n    write,\n    del,\n    delDir,\n    list,\n    touch,\n    mkdir,\n    getExec,\n    execRead,\n    chmod,\n    chown,\n    resolveWorkingPaths,\n    append,\n    dirExists,\n    fileExists,\n};","import FS, { IFSListEntry } from \"../Services/FileSystem\";\n\n\nexport interface IIdentityContainer {\n    getIdentity(): IIdentity;\n}\n\nexport interface IIdentity extends IIdentityContainer {\n    user: string;\n    groups: string[];\n    workingDir: string;\n    priveledged: boolean;\n    getEnv(name: string, fallback?: string): string;\n    setEnv(name: string, value: string | string[]): void;\n    changeWorkingPath(path: string): Promise<boolean>;\n}\n\nexport default class Identity implements IIdentity {\n    user: string;\n    groups: string[];\n    workingDir: string;\n    priveledged: boolean;\n    env: { [s: string]: string } = {};\n\n    constructor(user: string, groups: Array<String>, workingDir: string) {\n        groups = groups || [];\n        workingDir = workingDir || \"/\";\n\n        this.user = user.toLowerCase();\n        this.groups = [...groups, this.user]\n            .filter((e, i, a) => a.indexOf(e) === i)\n            .map(e => e.toLowerCase());\n        this.workingDir = workingDir;\n        this.priveledged = this.user === \"root\";\n        this.setEnv(\"path\", [\"/bin\"]);\n    }\n\n    setEnv(name: string, value: string | string[]): void {\n        if (value instanceof Array) {\n            value = value.join(\";\");\n        }\n        this.env[name] = value;\n    }\n\n    getEnv(name: string, fallback?: string): string {\n        if (this.env.hasOwnProperty(name)) {\n            return this.env[name];\n        }\n        return fallback || \"\";\n    }\n\n    getIdentity(): IIdentity {\n        return this.clone();\n    }\n\n    setPriveledged(priveleged: boolean): void {\n        this.priveledged = priveleged;\n    }\n\n    async changeWorkingPath(path: string): Promise<boolean> {\n        try {\n            const exists: IFSListEntry[] = await FS.list(path, this);\n            if (exists instanceof Array) {\n                this.workingDir = path;\n                return Promise.resolve(true);\n            }\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return Promise.resolve(false);\n    }\n\n    clone(): Identity {\n        const ident: Identity = new Identity(this.user + \"\", [...this.groups], this.workingDir + \"\");\n        ident.setPriveledged(this.priveledged === true);\n        Object.entries(this.env).forEach((entry: [string, string]) => {\n            ident.setEnv(entry[0], entry[1]);\n        });\n        return ident;\n    }\n}","import { IProcessManager } from \"../Services/ProcessManager\";\nimport FS from \"../Services/FileSystem\";\nimport { FunctionSignature, IDisplayItem } from \"../App/libOS\";\nimport { OSApi } from \"./Types\";\nimport Identity, { IIdentityContainer, IIdentity } from \"./Identity\";\nimport OSLib from \"./OSLib\";\n\n\nexport interface IProcess {\n    id: number;\n    exec: string;\n    params: string[];\n    identity: IIdentity;\n    // parent: IProcess | null;\n    dead: boolean;\n    parentID: number;\n}\n\nexport default class Process implements IProcess, IIdentityContainer {\n    manager: IProcessManager;\n    lib: OSLib;\n    code: string = \"\";\n\n    id: number;\n    identity: IIdentity;\n    params: string[];\n    exec: string;\n    dead: boolean = false;\n    children: { [s: number]: Process } = [];\n    app: any;\n\n    parentInCB: Function | null = null;\n    parentEndCB: Function | null = null;\n    parentID: number = -1;\n\n    private api: OSApi = {\n        Std: {\n            out: (data: any) => this.hasParent() ? this.intoParent(data) : this.api.Display.print({ data: data, over: 0 }),\n            in: (data: any) => this.intoChild(data.pid, data.data, data.source || null),\n        },\n        FS: {\n            list: (data: string) => FS.list(data, this),\n            mkdir: (data: string) => FS.mkdir(data, this),\n            resolve: (data: string[]) => FS.resolveWorkingPaths(data, this),\n            append: (data: { path: string, content: string }) => FS.append(data.path, data.content, this),\n            write: (data: { path: string, content: string }) => FS.write(data.path, data.content, this),\n            touch: (path: string) => FS.touch(path, this),\n            read: (path: string) => FS.read(path, this),\n            del: (path: string) => FS.del(path, this),\n            dirExists: (path: string) => FS.dirExists(path, this),\n            fileExists: (path: string) => FS.fileExists(path, this),\n            delDir: (path: string) => FS.delDir(path, this),\n        },\n        Process: {\n            end: () => this.kill(),\n            setEnv: (data: { prop: string, value: any, pid?: number }) => this.setEnv(data.prop, data.value, data.pid),\n            self: () => Promise.resolve(this.data()),\n            start: (data: any) => this.manager.startProcess(data.exec, data.params, null, this),\n            crash: (error: any) => { this.api.Std.out(error); return this.kill(); },\n            changeWorkingPath: (data: any) => this.changeWorkingPath(data),\n        },\n        Display: {\n            prompt: (text: string) => this.manager.getDisplay().setText(text),\n            print: (item: IDisplayItem) => this.manager.getDisplay().output(item.data, item.over, false),\n            printLn: (item: IDisplayItem) => this.manager.getDisplay().output(item.data, item.over, true),\n            info: () => this.manager.getDisplay().info(),\n        }\n    };\n\n    getIdentity(): IIdentity {\n        if (this.identity instanceof Identity) {\n            return this.identity.getIdentity();\n        } else {\n            return this.identity;\n        }\n    }\n\n    constructor(manager: IProcessManager, exec: string, pid: number, params: string[], identitC: IIdentity, parent?: Process) {\n        this.manager = manager;\n        //this.display = display;\n        this.exec = exec;\n        this.id = pid;\n        this.lib = new OSLib((signature: FunctionSignature, data: any) => this.call(signature, data));\n        this.identity = identitC.getIdentity();\n        this.params = params;\n        if (parent instanceof Process) {\n            this.parentID = parent.id;\n            const cbs: [Function, Function] = parent.registerChild(this);\n            this.parentInCB = cbs[0];\n            this.parentEndCB = cbs[1];\n        }\n    }\n\n    setEnv(prop: string, value: any, pid?: number): Promise<any> {\n        if (typeof pid === \"number\") {\n            if (pid === this.parentID || this.children.hasOwnProperty(pid)) {\n                return this.manager.setEnv(pid, prop, value);\n            } else {\n                return Promise.reject();\n            }\n        } else {\n            switch (prop) {\n                case \"log\":\n                    console.log(\"Process SET\", value);\n                    break;\n                case \"workingPath\":\n                case \"workingDir\":\n                    this.changeWorkingPath(value);\n                    break;\n                default:\n                    this.identity.setEnv(prop, value);\n                    break;\n            }\n            this.event([\"Process\", \"self\"], this.data());\n            return Promise.resolve();\n        }\n    }\n\n    start(code: string): boolean {\n        this.code = code;\n        const wrapper: string = [\n            \"((proc,osLib)=>{\\n\",\n            this.code,\n            \";\\nreturn new Main(proc,osLib);\\n})\"\n        ].join(\"\");\n\n        // tslint:disable: no-eval\n        this.app = eval(wrapper)(this.data, this.lib);\n        // tslint:enable: no-eval\n        return true;\n    }\n\n    hasParent(): boolean {\n        return this.parentID >= 0;\n    }\n\n    private intoParent(data: any): Promise<any> {\n        if (this.parentInCB !== null) {\n            this.parentInCB(data);\n            return Promise.resolve();\n        }\n        return Promise.reject();\n    }\n\n    call(signature: FunctionSignature, data: any): Promise<any> {\n        if (this.api.hasOwnProperty(signature.service)) {\n            if (this.api[signature.service].hasOwnProperty(signature.func)) {\n                return this.api[signature.service][signature.func](data);\n            }\n        }\n        return Promise.reject(\n            new Error([\n                \"PM Error\",\n                \"Atempt to access non-existant System Call\\n\" + signature.service + \">\" + signature.func,\n                this.exec + \"[\" + this.id + \"]\"\n            ].join(\" : \"))\n        );\n    }\n\n    data(): IProcess {\n        return {\n            id: this.id,\n            exec: this.exec,\n            params: [... this.params],\n            identity: this.identity,\n            dead: this.dead,\n            parentID: this.parentID,\n        };\n    }\n\n    registerChild(process: Process): [Function, Function] {\n        this.children[process.id] = process;\n        return [\n            (data: any) => {\n                this.stdIn(process.id, data);\n            },\n            () => { this.removeChild(process); }\n        ];\n    }\n\n    removeChild(process: Process): void {\n        this.event([\"Process\", \"end\"], process.id);\n        delete this.children[process.id];\n    }\n\n    intoChild(pid: number, source: number | string, data: any): Promise<any> {\n        if (this.children.hasOwnProperty(pid)) {\n            return this.children[pid].stdIn(source, data);\n        }\n        return Promise.reject();\n    }\n\n    stdIn(source: number | string, data: any): Promise<any> {\n        return this.event([\"Std\", \"in\"], { from: source, data });\n    }\n\n    async changeWorkingPath(path: string): Promise<any> {\n        this.identity.changeWorkingPath(path);\n    }\n\n    event(type: [string, string], data: any): Promise<any> {\n        return this.lib.fireEvent({ service: type[0], func: type[1] }, data);\n    }\n\n    kill(): Promise<any> {\n        this.dead = true;\n        delete this.app;\n        delete this.lib;\n        if (this.parentEndCB !== null) {\n            this.parentEndCB();\n        }\n        return Promise.resolve();\n    }\n}\n\n","import { ILibUtil } from \"../App/libOS\";\n\nexport const Util: ILibUtil = {\n    loadArgs: (args, opts, map): Promise<string[]> => {\n        let remain: string[] = [];\n        for (let i: number = 0; i < args.length; i++) {\n            let arg: any = args[i];\n            if (arg.startsWith(\"--\") && arg.length > 2) {\n                arg = arg.slice(2);\n                if (opts.hasOwnProperty(arg)) {\n                    if (i < args.length - 1 && !args[i + 1].startsWith(\"-\") && typeof opts[arg] !== \"boolean\") {\n                        i++;\n                        opts[arg] = args[i];\n                    } else {\n                        opts[arg] = !opts[arg];\n                    }\n                } else {\n                    return Promise.reject(\n                        new Error(\n                            [\"Load Args Error\",\n                                \"unrecognized option '--\" + arg + \"'\\nTry '--help' for more information.\",\n                                JSON.stringify(args)\n                            ].join(\" : \"))\n                    );\n                }\n            } else if (arg.startsWith(\"-\") && arg.length > 1 && arg !== \"--\") {\n                arg = arg.slice(1);\n                for (let j = 0; j < arg.length; j++) {\n                    const shrt: string = arg.charAt(j);\n                    if (map.hasOwnProperty(shrt)) {\n                        opts[map[shrt]] = !opts[map[shrt]];\n                    }\n                }\n            } else {\n                remain = [...remain, arg];\n            }\n        }\n        return Promise.resolve(remain);\n    },\n    bytesToHuman: (bytes, kibi, bits) => {\n        kibi = kibi === true;\n        bits = bits === true;\n        if (bits) bytes *= 8;\n        const step = kibi ? 1000 : 1024;\n        const set =\n            bits ?\n                (kibi ? [\"b\", \"kb\", \"mb\", \"gb\", \"pb\"] : [\"b\", \"Kb\", \"Mb\", \"Gb\", \"Pb\"])\n                :\n                (kibi ? [\"B\", \"kB\", \"mB\", \"gB\", \"pB\"] : [\"B\", \"KB\", \"MB\", \"GB\", \"PB\"])\n            ;\n        let o = 0;\n\n        while (bytes > step) {\n            bytes /= step;\n            o++;\n        }\n        return Math.round(bytes) + set[o];\n    }\n};\n\nexport default Util;","import { ILibOS, ILibStd, ILibFS, IStdInMsg, ILibProcess, ILibDisplay, ILibUtil } from \"../App/libOS\";\r\nimport { FunctionSignature, PromiseHolder } from \"./Types\";\r\nimport { IProcess } from \"./Process\";\r\nimport Util from \"./Util\";\r\n\r\nexport default class OSLib implements ILibOS {\r\n\r\n    private _call: (signature: FunctionSignature, data: any) => Promise<any>;\r\n    private hooks: { [s: string]: Function } = {};\r\n    private awaitProcs: { [s: number]: PromiseHolder } = {};\r\n\r\n    Std: ILibStd = {\r\n        event: {\r\n            in: (cb: (msg: IStdInMsg) => void) => this.hookEvent(\"Std\", \"in\", cb),\r\n        },\r\n        out: (data: any) => this.call(\"Std\", \"out\", data),\r\n        in: (pid: number, data: any, source?: string | number) => this.call(\"Std\", \"in\", { pid, data, source }),\r\n    };\r\n    FS: ILibFS = {\r\n        list: (path: string) => this.call(\"FS\", \"list\", path),\r\n        mkdir: (path: string) => this.call(\"FS\", \"mkdir\", path),\r\n        resolve: (paths: string[]) => this.call(\"FS\", \"resolve\", paths),\r\n        append: (path: string, content: string) => this.call(\"FS\", \"append\", { path, content }),\r\n        write: (path: string, content: string) => this.call(\"FS\", \"write\", { path, content }),\r\n        touch: (path: string) => this.call(\"FS\", \"touch\", path),\r\n        read: (path: string) => this.call(\"FS\", \"read\", path),\r\n        del: (path: string) => this.call(\"FS\", \"del\", path),\r\n        dirExists: (path: string) => this.call(\"FS\", \"dirExists\", path),\r\n        fileExists: (path: string) => this.call(\"FS\", \"fileExists\", path),\r\n        delDir: (path: string) => this.call(\"FS\", \"delDir\", path),\r\n    };\r\n    Process: ILibProcess = {\r\n        event: {\r\n            start: (cb: Function) => this.hookEvent(\"Process\", \"start\", cb),\r\n            msg: (cb: Function) => this.hookEvent(\"Process\", \"msg\", cb),\r\n            end: (cb: Function) => this.hookEvent(\"Process\", \"end\", cb),\r\n            self: (cb: Function) => this.hookEvent(\"Process\", \"self\", cb),\r\n        },\r\n        end: () => this.call(\"Process\", \"end\"),\r\n        //setSelf: (prop: string, value: any) => this.call(\"Process\", \"setSelf\", { prop, value }),\r\n        self: () => this.call(\"Process\", \"self\"),\r\n        start: (exec: string, params: string[]) => this.call(\"Process\", \"start\", { exec, params }),\r\n        crash: (error: any) => this.call(\"Process\", \"crash\", error),\r\n        changeWorkingPath: (path: string) => this.call(\"Process\", \"changeWorkingPath\", path),\r\n        msg: (pid: number, msg: any) => this.call(\"Process\", \"msg\", { pid, msg }),\r\n        kill: (pid: number) => this.call(\"Process\", \"kill\", pid),\r\n        list: () => this.call(\"Process\", \"list\"),\r\n        startAndAwaitOutput: (exec: string, params: string[]) => this.startAndAwait(exec, params),\r\n    };\r\n    Display: ILibDisplay = {\r\n        prompt: (text: string) => this.call(\"Display\", \"prompt\", text),\r\n        printRaw: (data: string | String[] | Array<string[]>, over: number, newLine: boolean) => this.call(\"Display\", \"print\", { data: data, over: over || 0, newLine: newLine === true }),\r\n        print: (data: string | String[] | Array<string[]>, over?: number) => this.Display.printRaw(data, over, false),\r\n        printLn: (data: string | String[] | Array<string[]>, over?: number) => this.Display.printRaw(data, over, true),\r\n        info: () => this.call(\"Display\", \"info\"),\r\n    };\r\n\r\n    Util: ILibUtil = Util;\r\n\r\n    constructor(call: (signature: FunctionSignature, data: any) => Promise<any>) {\r\n        this._call = call;\r\n    }\r\n\r\n    private call(service: string, func: string, data?: any): Promise<any> {\r\n        return this._call({ service: service, func: func }, data);\r\n    }\r\n\r\n    private hookEvent(service: string, func: string, cb: Function): void {\r\n        const event: string = service + \":\" + func;\r\n        this.hooks[event] = cb;\r\n    }\r\n\r\n    private startAndAwait(exec: string, params: string[]): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            this.Process.start(exec, params)\r\n                .then((proc: IProcess) => {\r\n                    this.awaitProcs[proc.id] = {\r\n                        resolve: resolve,\r\n                        reject: reject,\r\n                    };\r\n                })\r\n                .catch(e => reject(e));\r\n        });\r\n    }\r\n\r\n    fireEvent(signature: FunctionSignature, data: any): Promise<any> {\r\n        return this.fireHooks(signature, data);\r\n    }\r\n\r\n    private awaitIn(msg: IStdInMsg): boolean {\r\n        if (typeof msg.from === \"number\" && this.awaitProcs.hasOwnProperty(msg.from)) {\r\n            this.awaitProcs[msg.from].resolve(msg);\r\n            delete this.awaitProcs[msg.from];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private fireHooks(signature: FunctionSignature, data: any): Promise<any> {\r\n        const event: string = signature.service + \":\" + signature.func;\r\n        if (event === \"Std:in\") {\r\n            if (this.awaitIn(data)) {\r\n                return Promise.resolve();\r\n            }\r\n        }\r\n        if (this.hooks.hasOwnProperty(event)) {\r\n            return this.hooks[event](data);\r\n        }\r\n        return Promise.reject(\"MISSING\")\r\n    }\r\n}","import { IProcessManager } from \"./ProcessManager\";\n\ninterface IQueuedDisplayItem {\n    text: any[];\n    over: number;\n}\n\nexport interface IDisplay {\n    init(pm: IProcessManager): void;\n    setText(text: string): Promise<any>;\n    output(data: any, over?: number, newLine?: boolean): Promise<any>;\n    info(): Promise<any>;\n}\n\nexport class StubDisplay implements IDisplay {\n    init(pm: IProcessManager): void {\n        console.log(\"STUB DISPLAY INIT\", pm);\n    }\n    setText(text: string): Promise<any> {\n        console.log(\"STUB DISPLAY SET TEXT\", text);\n        return Promise.resolve();\n    }\n    output(data: any, over?: number, newLine?: boolean): Promise<any> {\n        console.log(\"STUB DISPLAY OUTPUT\", data, over, newLine);\n        return Promise.resolve();\n    }\n    info(): Promise<any> {\n        console.log(\"STUB DISPLAY INFO\");\n        return Promise.resolve({});\n    }\n}\n\nexport default class Display implements IDisplay {\n    display: HTMLDivElement;\n    input: HTMLSpanElement;\n\n    queuedItems: IQueuedDisplayItem[] = [];\n\n    processManager: IProcessManager | null = null;\n\n    constructor() {\n        this.display = document.createElement(\"div\");\n        this.input = document.createElement(\"span\");\n    }\n\n    info(): Promise<any> {\n        return Promise.resolve({});\n    }\n\n    init(processManager: IProcessManager): void {\n        this.processManager = processManager;\n        this.createDisplay();\n        document.addEventListener(\"keydown\", () => {\n            if (document.activeElement !== this.input) {\n                this.input.focus();\n            }\n        });\n\n        this.input.addEventListener(\"keydown\", (ev: KeyboardEvent) => {\n            if (ev.ctrlKey && ev.key !== \"Control\" && !ev.repeat && ev.key !== \"F5\") {\n                this.controlKey(ev.key);\n            } else if ((ev.key === \"ArrowUp\" || ev.key === \"ArrowDown\") && !ev.repeat) {\n                this.history(ev.key === \"ArrowDown\" ? -1 : 1);\n            } else if (ev.key === \"Enter\") {\n                if (!ev.repeat) {\n                    this.enterText();\n                }\n            } else if (ev.key === \"Tab\") {\n                this.tabKey();\n                console.log(\"TAB KEY\");\n                ev.preventDefault();\n            } else {\n                return;\n            }\n            ev.preventDefault();\n        });\n        this.processQueue();\n    }\n\n    private colourizeText(text: string): HTMLElement[] {\n        const segments: string[] = text.split(/(?=§[0-9A-F]{6})/);\n        return segments.map((txt: string): HTMLElement => {\n            const span: HTMLSpanElement = document.createElement(\"span\");\n            if (txt.startsWith(\"§\")) {\n                const colours: String = txt.slice(0, 7);\n                span.setAttribute(\"style\", \"color:#\" + colours.slice(1, 4) + \";background-color:#\" + colours.slice(4, 7) + \";\");\n                txt = txt.slice(7);\n            }\n            span.textContent = txt;\n            return span;\n        });\n    }\n\n    private breakUptext(text: string): HTMLElement[] {\n        const elements: HTMLElement[] = [];\n\n        text.split(\"\\n\").forEach((t: string, index: number, array: string[]) => {\n            const span: HTMLSpanElement = document.createElement(\"span\");\n            this.colourizeText(t).forEach((e: HTMLElement) => {\n                span.append(e);\n            });\n            elements.push(span);\n            if (index < (array.length - 1)) {\n                elements.push(document.createElement(\"br\"));\n            }\n        });\n\n        return elements;\n    }\n\n\n    private writeToDisplay(text: any[], over?: number): void {\n        over = over || 0;\n        text.map((e) => {\n            this.display.insertBefore(e, this.input);\n        });\n    }\n\n    private reduceArrayForDisplay(data: Array<any>, level: number): string {\n        return data.reduce((out: string, inp: any, index: number) => {\n            const type: string = typeof inp;\n            if (type === \"string\" || type === \"number\") {\n                out += (index < 1 ? \"\" : \"\\t\") + inp;\n            } else {\n                if (inp instanceof Array) {\n                    out += (index < 1 ? \"\" : \"\\n\") + this.reduceArrayForDisplay(inp, level + 1);\n                }\n            }\n            return out;\n        }, \"\");\n    }\n\n    private processDisplayData(data: any): string {\n        if (data instanceof Array) {\n            return this.reduceArrayForDisplay(data, 0);\n        }\n        console.log(data);\n        return \"FAILED TO CONVERT FOR DISPLAY\";\n    }\n\n    output(data: any, over?: number, newLine?: boolean): Promise<any> {\n        newLine = newLine === true;\n        let text: string = \"\";\n        if (typeof data !== \"string\") {\n            text = this.processDisplayData(data);\n        } else {\n            text = data;\n        }\n        const items: HTMLElement[] = this.breakUptext(text);\n        if (newLine) {\n            items.push(document.createElement(\"br\"));\n        }\n        this.writeToDisplay(items, over);\n        return Promise.resolve();\n    }\n\n    prompt(show: boolean): void {\n        console.log(\"PROMPT\", show);\n    }\n\n\n    private processQueue(): void {\n        this.queuedItems.map((item: IQueuedDisplayItem) => {\n            this.writeToDisplay(item.text, item.over);\n        });\n    }\n\n    private createDisplay(): void {\n        this.display.id = \"output\";\n        this.display.tabIndex = -1;\n        this.input.id = \"input\";\n        this.input.tabIndex = 0;\n        this.input.contentEditable = \"true\";\n        this.input.spellcheck = false;\n        const body: HTMLBodyElement | null = document.querySelector(\"body\");\n        if (body !== null) {\n            body.append(this.display);\n            this.display.append(this.input);\n        }\n    }\n\n    private history(dir: 1 | -1): void {\n        this.specialUserInput(\"DIR\", dir.toString());\n    }\n\n    private controlKey(key: string): void {\n        this.inputOutput(false);\n        this.specialUserInput(\"CTRL\", key);\n    }\n\n    public setText(text: string): Promise<any> {\n        this.input.textContent = text;\n        const range = document.createRange() || new Range();\n        var sel: Selection = window.getSelection() || new Selection();\n        const childs = this.input.childNodes;\n        console.log(\"DISPLAY\", childs[childs.length - 1]);\n        if (text.length > 0) {\n            range.setStart(childs[childs.length - 1], this.input.textContent.length);\n        } else {\n            range.setStart(this.input, this.input.textContent.length);\n        }\n        range.collapse(true);\n        sel.removeAllRanges();\n        sel.addRange(range);\n        this.input.focus();\n        return Promise.resolve();\n        // const range = document.createRange();//Create a range (a range is a like the selection but invisible)\n        // range.selectNodeContents(contentEditableElement);//Select the entire contents of the element with the range\n        // range.collapse(false);//collapse the range to the end point. false means collapse to end rather than the start\n        // selection = window.getSelection();//get the selection object (allows you to change selection)\n        // selection.removeAllRanges();//remove any selections already made\n        // selection.addRange(range);\n    }\n\n    private enterText(): void {\n        const text: string = this.inputOutput();\n        if (text.length > 0) {\n            this.userInput(text);\n            this.setText(\"\");\n        }\n    }\n\n    private inputOutput(newLine?: boolean): string {\n        newLine = newLine !== false;\n        const text: string = this.input.textContent || \"\";\n        if (text.length > 0) {\n            this.output(text, 0, newLine);\n        }\n        return text;\n    }\n\n    private specialUserInput(type: string, text: string): void {\n        this.userInput(\"§§§\" + type + \"§§§\" + text);\n    }\n\n    private userInput(text: string): void {\n        if (this.processManager !== null) {\n            this.processManager.stdIn(\"user\", text);\n        }\n    }\n\n    private tabKey(): void {\n        this.specialUserInput(\"tab\", this.input.textContent || \"\");\n    }\n}","import ls from \"./ls\";\nimport bash from \"./bash\";\nimport mkdir from \"./mkdir\";\nimport cat from \"./cat\";\nimport touch from \"./touch\";\nimport rm from \"./rm\";\nimport cd from \"./cd\";\nimport tail from \"./tail\";\nimport head from \"./head\";\nimport edit from \"./edit\";\n\nexport const DefaultApps: { [s: string]: Function } = {\n    ls,\n    bash,\n    mkdir,\n    cat,\n    touch,\n    rm,\n    cd,\n    tail,\n    head,\n    edit,\n};","import { IFSListEntry } from \"../../Services/FileSystem\";\nimport { ILibOS, AppOpts, AppOptsMap } from \"../libOS\";\nimport { ILibCMD } from \"../../Services/Cmd\";\nimport { IProcess } from \"../../Struct/Process\";\n\ndeclare var CMD: ILibCMD;\ndeclare var OS: ILibOS;\ndeclare var PROCESS: IProcess;\n\nconst ls: Function = (): void => {\n    const opts: AppOpts = {\n        all: false,\n        human: false,\n        long: false,\n        \"no-group\": false,\n        raw: false,\n    };\n\n    let count: number;\n    let done: number = 0;\n\n    const argMap: AppOptsMap = {\n        a: \"all\",\n        h: \"human\",\n        l: \"long\",\n        G: \"no-group\",\n    };\n\n    const formatFileName: Function = (entry: IFSListEntry): string => {\n        let name: string = entry.name;\n        if (opts.raw) {\n            return name;\n        }\n        if (name.indexOf(\" \") >= 0) {\n            name = \"'\" + name + \"'\"\n        }\n        let fore: string = CMD.Colours.white;\n        let back: string = CMD.Colours.black;\n        if (!entry.file) {\n            fore = CMD.Colours.blue;\n        }\n        return CMD.Colourize(name, fore, back);\n    };\n\n    const longOutputEntry: Function = (entry: IFSListEntry): any[] => {\n        const out: { [s: string]: any } = {\n            perms: entry.perms,\n            user: entry.user,\n            group: entry.group,\n            size: entry.size,\n            name: formatFileName(entry),\n        };\n        if (opts[\"no-group\"]) {\n            delete out.group;\n        }\n        return Object.values(out);\n    };\n\n    const longOutput: Function = (path: string, data: Array<IFSListEntry>) => {\n        let arr: Array<string[] | string> = [\n            path,\n            [\"perms\\t\", \"user\", opts[\"no-group\"] ? \"\" : \"group\", \"size\", \"name\"].filter(c => c.length > 0)\n        ];\n        data.map(d => longOutputEntry(d)).map(e => arr.push(e));\n        return arr;\n    };\n\n    const shortOutput: Function = (data: Array<IFSListEntry>): string[] => data.map(e => formatFileName(e));\n\n    const output: Function = (path: string, data: Array<IFSListEntry>) => {\n        if (!opts.all) {\n            data = data.filter(d => !d.name.startsWith(\".\"));\n        }\n        if (opts.human) {\n            // todo : Human Sizes\n            // data.forEach(d => {\n            //     d.size = OS.Util.bytesToHuman(d.size);\n            // });\n        }\n        let result: string[] | Array<string[]>;\n        result = opts.long ? longOutput(path, data) : shortOutput(data);\n\n        OS.Std.out(result);\n\n        done++;\n        if (done >= count) {\n            OS.Process.end();\n        }\n    };\n\n    const error: Function = (e: any) => {\n        OS.Process.crash(e);\n    };\n\n    const list: Function = (path: string) => {\n        OS.FS.list(path)\n            .then((data: Array<Object>) => output(path, data))\n            .catch((e: any) => error(e));\n    };\n\n    const start: Function = async (data: string[]) => {\n        try {\n            let paths = await OS.Util.loadArgs(data, opts, argMap);\n            count = paths.length;\n            if (count < 1) {\n                paths = [\"\"];\n                count = 1;\n            }\n            paths.map(s => list(s));\n        } catch (e) {\n            error(e);\n        }\n\n    };\n    start(PROCESS.params);\n};\n\nexport default ls;","import { ILibCMD } from \"../../Services/Cmd\";\nimport { ILibOS, IStdInMsg } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\ndeclare var CMD: ILibCMD;\n\nexport default class Main {\n    bashHistoryFile: string = \"~/.bash_history\";\n\n    bashProcess: IProcess;\n\n    host: string = window.location.origin.split(\"://\")[1].split(\":\")[0] || \"[MISSING HOST]\";\n    activeProcessID: number = -1;\n    activeOutputed: boolean = false;\n\n    subProcs: { [s: number]: IProcess } = {};\n\n    history: string[] = [];\n    historyPosition: number = 0;\n\n    api: ILibOS;\n\n    constructor(process: IProcess, OS: ILibOS) {\n        this.bashProcess = process;\n        this.api = OS;\n        this.api.Process.event.self((proc: IProcess) => this.selfUpdate(proc));\n        this.api.Process.event.end((pid: number): Promise<any> => this.end(pid));\n        this.api.Std.event.in((data: IStdInMsg) => this.stdIn(data));\n        this.start();\n    }\n\n    setHistoryPosition(pos: number): void {\n        this.historyPosition = Math.min(Math.max(pos, 0), history.length);\n    }\n\n    showHistory(pos: number): void {\n        this.setHistoryPosition(pos);\n        this.api.Display.prompt(this.history[this.history.length - this.historyPosition]);\n    }\n\n    newHistory(input: string) {\n        if (input.length > 0 && input !== this.history[this.history.length - 1]) {\n            this.history.push(input);\n            this.api.FS.append(this.bashHistoryFile, input + \"\\n\");\n        }\n        this.historyPosition = 0;\n    }\n\n    getSubProc(pid: number): IProcess | null {\n        if (this.subProcs.hasOwnProperty(pid)) {\n            return this.subProcs[pid];\n        }\n        return null;\n    }\n\n    printPrompt(newLine?: boolean): void {\n        newLine = newLine === true;\n        this.api.Std.out(\n            (newLine ? \"\\n\" : \"\")\n            +\n            CMD.Colourize(this.bashProcess.identity.user + \"@\" + this.host, CMD.Colours.green)\n            +\n            CMD.Colourize(\":\", CMD.Colours.white)\n            +\n            CMD.Colourize(this.bashProcess.identity.workingDir.replace(\"/home/\" + this.bashProcess.identity.user, \"~\"), CMD.Colours.blue)\n            +\n            CMD.Colourize(\"$ \", CMD.Colours.white)\n        );\n    }\n\n    splitUserInput(text: string): string[] {\n        const parts = text.match(/(\".*?\"|[^\" \\s]+)(?=\\s* |\\s*$)/g) || [];\n        return parts.map(s => {\n            s = s.trim();\n            if (s.charAt(0) === '\"' && s.charAt(s.length - 1) === '\"') {\n                s = s.slice(1, s.length - 1);\n            }\n            return s;\n        });\n    }\n\n    start() {\n        this.api.FS.read(this.bashHistoryFile)\n            .then((content: string) => {\n                this.history = content.split(\"\\n\")\n                    .filter(s => s.length > 0)\n                    .filter((s, i, a) => i > 0 && a[i - 1] !== s);\n            });\n        this.printPrompt();\n    }\n\n    resolveAppIn(msg: IStdInMsg): Promise<any> {\n        const proc: IProcess | null = this.getSubProc(parseInt(msg.from));\n        let output: any = msg.data;\n        if (msg.data instanceof Array && proc !== null) {\n            if (msg.data[0] === \"ERROR\") {\n                output = proc.exec.split(\"/\").pop() + \": \" + msg.data[2];\n            }\n        }\n        if (parseInt(msg.from, 10) === this.activeProcessID) {\n            this.activeOutputed = true;\n        }\n        this.api.Std.out(output);\n        return Promise.resolve(\"asd\");\n    }\n\n    ctrlCode(type: string): void {\n        console.log(\"CTRL CODE\", type);\n        switch (type) {\n            case \"c\":\n                this.api.Std.out(\"^C\");\n                this.printPrompt(true);\n                this.api.Display.prompt(\"\");\n                break;\n        }\n    }\n\n    async tabComplete(text: string) {\n        const parts = this.splitUserInput(text);\n        let prompt: any = null\n        if (parts.length === 1) {\n\n        } else {\n            const part = parts[parts.length - 1];\n            const dirs = part.split(\"/\");\n            const dir = dirs.slice(0, dirs.length - 1).join(\"/\");\n            const t = dirs[dirs.length - 1];\n            const args = [\"--raw\"];\n            if (t.startsWith(\".\")) {\n                args.push(\"--all\");\n            }\n            args.push(dir);\n            const ls = await this.api.Process.startAndAwaitOutput(\"ls\", args);\n            const opts = ls.data;\n            console.log({ text, parts, dirs, dir, t, opts });\n            const result = opts.filter((e: string) => e.startsWith(t));\n            if (result.length === 1) {\n                dirs[dirs.length - 1] = result[0];\n                const d = dirs.join(\"/\");\n                console.log(d);\n                const isDir = await this.api.FS.dirExists(d);\n                parts[parts.length - 1] = d + (isDir ? \"/\" : \"\");\n            } else {\n                prompt = opts;\n            }\n        }\n        if (prompt !== null) {\n            this.api.Std.out(text + \"\\n\");\n            this.api.Std.out(prompt);\n            this.printPrompt(true);\n        }\n        this.api.Display.prompt(parts.map((s: string) => s.indexOf(\" \") >= 0 ? '\"' + s + '\"' : s).join(\" \"));\n\n    }\n\n    specialCode(code: string): void {\n        const parts: string[] = code.split(\"§§§\").filter(s => s.length > 0);\n        switch (parts[0].toLowerCase()) {\n            case \"ctrl\":\n                this.ctrlCode(parts[1]);\n                break;\n            case \"dir\":\n                this.showHistory(parseInt(parts[1], 10) + this.historyPosition);\n                break;\n            case \"tab\":\n                this.tabComplete(parts[1]);\n                break;\n            default:\n                console.log(\"SPECIAL CODE\", parts);\n                break;\n        }\n    }\n\n    selfUpdate(data: IProcess): Promise<any> {\n        console.log(\"UPDATE SELF\", data);\n        this.bashProcess = data;\n        return Promise.resolve();\n    }\n\n    async stdIn(data: IStdInMsg) {\n        if (data.from === \"user\") {\n            if (typeof data.data === \"string\") {\n                if (data.data.startsWith(\"§§§\")) {\n                    this.specialCode(data.data);\n                } else {\n                    if (this.activeProcessID > 0) {\n                        console.log(\"PASS ON STD IN\", this.bashProcess.id);\n                        this.api.Std.in(this.activeProcessID, data.data, data.from);\n                        return;\n                    }\n                    if (data.data === \"exit\") {\n                        this.api.Process.end();\n                        return;\n                    }\n                    const parts: string[] = this.splitUserInput(data.data);\n                    const exec: string = parts.shift() || \"\";\n                    try {\n                        const proc = await this.api.Process.start(exec, parts);\n                        this.activeOutputed = false;\n                        this.subProcs[proc.id] = proc;\n                        this.activeProcessID = proc.id;\n                    } catch (e) {\n                        console.log(\"EXEC ERROR\", e);\n                        try {\n                            if (e[1] === \"FS Error\" && e[3] === \"Not found\") {\n                                this.api.Std.out(exec + \": command not found\");\n                            } else {\n                                this.api.Std.out(e[1]);\n                            }\n                        } catch (er) {\n                            this.api.Std.out([\"BASH LAUNCH ERROR\", er.message]);\n                        }\n                        this.printPrompt(true);\n                    }\n                    this.newHistory(data.data);\n                }\n            }\n        } else {\n            const resolve = await this.resolveAppIn(data);\n            if (typeof resolve !== \"string\") {\n                console.log(resolve);\n            }\n        }\n    }\n    end(pid: number): Promise<any> {\n        const sub: IProcess | null = this.getSubProc(pid);\n        if (sub !== null) {\n            delete this.subProcs[pid];\n            if (pid === this.activeProcessID) {\n                this.activeProcessID = -1;\n                this.printPrompt(this.activeOutputed);\n            }\n        }\n        return Promise.resolve();\n    }\n}","import { ILibOS } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\ndeclare var OS: ILibOS;\ndeclare var PROCESS: IProcess;\n\nconst mkdir: Function = () => {\n\n    const help: string[][] = [\n        [\"Usage: mkdir[OPTION]...DIRECTORY...\"],\n        [\"Create the DIRECTORY(ies), if they do not already exist.\"],\n        [\"\"],\n        [\"Mandatory arguments to long options are mandatory for short options too.\"],\n        //        [\"  - m, --mode= MODE\", \"set file mode(as in chmod), not a = rwx - umask\"],\n        [\"  - p, --parents\", \"no error if existing, make parent directories as needed\"],\n        [\"  - v, --verbose\", \"print a message for each created directory\"],\n        //        [\"  - Z\", \"\", \"\", \"set SELinux security context of each created directory\"],\n        //        [\"  \", \"\", \"\", \"to the default type\"],\n        [\"  \", \"--help\", \"\", \"display this help and exit\"],\n        [\"  \", \"--version\", \"output version information and exit\"],\n    ];\n\n    const version: string = [\n        \"mkdir (GNU coreutils) 0.1\",\n        \"Copyright(C) 2010 wlf.io.\",\n        \"License MIT License < https://raw.githubusercontent.com/wlfio/TSPseudoOS/master/LICENSE >.\",\n        \"This is free software: you are free to change and redistribute it.\",\n        \"There is NO WARRANTY, to the extent permitted by law.\",\n        \"\",\n        \"Written by wlf.io.\"\n    ].join(\"\\n\");\n\n    const options: { [s: string]: any } = {\n        help: false,\n        version: false,\n        verbose: false,\n        parents: false,\n    };\n    const optMap: { [s: string]: string } = {\n        \"?\": \"help\",\n        v: \"verbose\",\n        p: \"parents\"\n    };\n\n    const error: Function = (e: any) => {\n        if (e instanceof Array) {\n            if (e[2] === \"Path is not directory\") {\n                e = new Error(\"MKDIR ERROR : no such file or directory '\" + e[3] + \"' : \" + e.join(\" : \"));\n            }\n        }\n        OS.Process.crash(e);\n    };\n\n    const breakPathIntoParentPaths: Function = (path: string): string[] => {\n        const parts: string[] = path.split(\"/\").filter(s => s.length > 0);\n        return parts.reduce((out: string[], inp: string, i: number) => {\n            if (i === 0) {\n                inp = \"/\" + inp;\n            } else {\n                inp = out[out.length - 1] + \"/\" + inp;\n            }\n            out.push(inp);\n            return out;\n        }, []);\n    };\n\n    const breakPathsIntoParentPaths: Function = (paths: string[]): Array<string[]> => {\n        return paths.map((path: string) => {\n            if (options.parents) {\n                return breakPathIntoParentPaths(path);\n            }\n            return [path];\n        });\n    };\n\n    let count: number = 0;\n    const make: Function = async (rawPaths: string[]): Promise<any> => {\n        let prefix: string = \"\";\n        try {\n            const paths: string[] = await OS.FS.resolve(rawPaths);\n            console.log(\"PATHS\", paths);\n            const broken: string[][] = breakPathsIntoParentPaths(paths);\n            console.log(\"BROKEN\", broken);\n            for (let j: number = 0; j < broken.length; j++) {\n                const set: string[] = broken[j];\n                for (let i: number = 0; i < set.length; i++) {\n                    const path: string = set[i];\n                    const done: boolean = await OS.FS.mkdir(path);\n                    console.log(\"PATH DONE\", path, done);\n                    if (options.verbose && done) {\n                        OS.Std.out(prefix + \"created directory '\" + set[count] + \"'\");\n                    }\n                    if (!done && (!options.parents)) {\n                        OS.Std.out(prefix + \"cannot create directory '\" + set[count] + \"': File exists\");\n                    }\n                    prefix = \"\\n\";\n                }\n            }\n            OS.Process.end();\n        } catch (e) {\n            console.log(\"ERROROR\", e);\n            error(e);\n        }\n    };\n\n    const start: Function = async (args: string[]) => {\n        const params: string[] = await OS.Util.loadArgs(args, options, optMap);\n        if (params.length < 1 && !options.help && !options.version) {\n            OS.Process.crash(\n                new Error([\n                    \"mkdir error\",\n                    \"missing operand\\nTry 'mkdir --help' for more information\"\n                    , JSON.stringify(args)].join(\" : \")\n                )\n            );\n            return;\n        }\n        if (options.help) {\n            OS.Std.out(help);\n        } else if (options.version) {\n            OS.Std.out(version);\n        } else {\n            make(params);\n        }\n    };\n\n    start(PROCESS.params);\n};\n\nexport default mkdir;","import { ILibOS, AppOptsMap, AppOpts } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\ndeclare var OS: ILibOS;\ndeclare var PROCESS: IProcess;\n\nconst cat: Function = () => {\n\n    const options: AppOpts = {\n        number: false,\n        \"squeeze-blank\": false,\n    };\n\n    const optMap: AppOptsMap = {\n        n: \"number\",\n        s: \"squeeze-blank\",\n    };\n\n    let count: number = 0;\n\n    const error: Function = (e: any) => {\n        OS.Process.crash(e);\n    };\n\n    const splitLines: Function = (content: string): string[][] => {\n        const lines: string[][] = [];\n        let empty: boolean = false;\n        content.split(\"\\n\").forEach((txt: string) => {\n            count++;\n            if (txt.length < 1) {\n                if (empty) {\n                    return;\n                }\n                empty = true;\n            } else {\n                empty = false;\n            }\n            const line: string[] = [];\n            if (options.number) {\n                line.push(count.toString());\n            }\n            line.push(txt);\n            lines.push(line);\n        });\n        return lines;\n    };\n\n    const output: Function = (content: string) => {\n        OS.Std.out(splitLines(content));\n    };\n\n    const cat: Function = async (paths: string[]): Promise<any> => {\n        try {\n            for (let i: number = 0; i < paths.length; i++) {\n                const content: string | null = await OS.FS.read(paths[i]);\n                output(content);\n            }\n            OS.Process.end();\n        } catch (e) {\n            error(e);\n        }\n    };\n\n    const start: Function = (data: string[]) => {\n        OS.Util.loadArgs(data, options, optMap)\n            .then((paths: string[]) => {\n                if (paths.length < 1) {\n                    throw new Error(\"CAT ERROR : you must include file path(s) : \" + JSON.stringify(data));\n                }\n                cat(paths);\n            })\n            .catch((e: any) => {\n                console.log(\"CAT ERROR\", e);\n                error(e);\n            });\n    };\n\n    start(PROCESS.params);\n};\n\nexport default cat;","import { ILibOS, AppOpts, AppOptsMap } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\nconst touch: Function = (process: IProcess, OS: ILibOS) => {\n\n    class Touch {\n        options: AppOpts = {\n            verbose: false,\n        };\n        optMap: AppOptsMap = {\n            v: \"verbose\",\n        }\n        constructor(params: string[]) {\n            this.loadArgs(params);\n        }\n        firstOut: boolean = true;\n\n        async loadArgs(params: string[]) {\n            try {\n                const paths = await OS.Util.loadArgs(params, this.options, this.optMap);\n                this.run(paths);\n            } catch (e) {\n                this.error(e);\n            }\n        }\n\n        error(e: any): void {\n            OS.Process.crash(e);\n        }\n\n        async run(paths: string[]) {\n            for (let i: number = 0; i < paths.length; i++) {\n                const out = await OS.FS.touch(paths[i]);\n                this.printOutput(out);\n            }\n            OS.Process.end();\n        }\n\n        printOutput(out: any): void {\n            if (this.options.verbose) {\n                OS.Std.out((this.firstOut ? \"\" : \"\\n\") + \"created '\" + out[0] + \"'\");\n                this.firstOut = false;\n            }\n        }\n    }\n\n    new Touch(process.params);\n};\n\nexport default touch;","import { ILibOS, AppOpts, AppOptsMap } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\ndeclare var OS: ILibOS;\ndeclare var PROCESS: IProcess;\n\nconst rm: Function = () => {\n\n    class RM {\n        options: AppOpts = {\n            verbose: false,\n            recursive: false,\n        };\n        optMap: AppOptsMap = {\n            v: \"verbose\",\n            r: \"recursive\",\n        }\n        constructor(params: string[]) {\n            this.loadArgs(params);\n        }\n        firstOut: boolean = true;\n\n        async loadArgs(params: string[]) {\n            try {\n                const paths = await OS.Util.loadArgs(params, this.options, this.optMap);\n                this.run(paths);\n            } catch (e) {\n                this.error(e);\n            }\n        }\n\n        error(e: any): void {\n            OS.Process.crash(e);\n        }\n\n        async run(paths: string[]) {\n            try {\n                paths = await OS.FS.resolve(paths);\n                for (let i: number = 0; i < paths.length; i++) {\n                    const path = paths[i];\n                    const dir = await OS.FS.dirExists(path);\n                    let out;\n                    if (dir) {\n                        if (!this.options.recursive) {\n                            this.printDirError(path);\n                        } else {\n                            out = await OS.FS.delDir(path);\n                        }\n                    } else {\n                        out = await OS.FS.del(path);\n                    }\n                    //const ls = await OS.FS.list(paths[i]);\n                    //console.log(ls);\n                    this.printOutput(out);\n                }\n                OS.Process.end();\n            } catch (e) {\n                this.error(e);\n            }\n        }\n\n        printOutput(out: any): void {\n            if (this.options.verbose) {\n                this.output(\"deleted '\" + out[0] + \"'\");\n            }\n        }\n\n        printDirError(path: string): void {\n            this.output(\"cannot remove '\" + path + \"' it's a directory\");\n        }\n\n        output(text: string) {\n            OS.Std.out((this.firstOut ? \"\" : \"\\n\") + \"rm: \" + text);\n            this.firstOut = false;\n        }\n    }\n\n    new RM(PROCESS.params);\n};\n\nexport default rm;","import { ILibOS, AppOpts, AppOptsMap } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\nexport default class Main {\n    private api: ILibOS;\n    private proc: IProcess;\n    options: AppOpts = {\n    };\n    optMap: AppOptsMap = {\n    }\n    constructor(process: IProcess, OS: ILibOS) {\n        this.api = OS;\n        this.proc = process;\n        this.loadArgs(process.params);\n    }\n    firstOut: boolean = true;\n\n    async loadArgs(params: string[]) {\n        try {\n            const paths = await this.api.Util.loadArgs(params, this.options, this.optMap);\n            this.run(paths);\n        } catch (e) {\n            this.error(e);\n        }\n    }\n\n    error(e: any): void {\n        this.api.Process.crash(e);\n    }\n\n    async run(paths: string[]) {\n        try {\n            if (this.proc.parentID > 0) {\n                paths = await this.api.FS.resolve(paths);\n                const result = await this.api.Process.changeWorkingPath(paths[0], this.proc.parentID);\n                console.log(\"CHANGE DIR\", result);\n            }\n            //console.log(PROCESS, paths);\n            this.api.Process.end();\n        } catch (e) {\n            this.error(e);\n        }\n    }\n}","import { ILibOS, AppOptsMap, AppOpts } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\n\ndeclare var OS: ILibOS;\ndeclare var PROCESS: IProcess;\n\n\nconst tail: Function = () => {\n    class Tail {\n        options: AppOpts = {\n            follow: false,\n        };\n\n        optMap: AppOptsMap = {\n            f: \"follow\",\n        };\n\n        files: { [s: string]: string | null } = {};\n\n        constructor(process: IProcess) {\n            this.loadArgs(process.params);\n        }\n\n        error(e: any) {\n            OS.Process.crash(e);\n        }\n\n        async loadArgs(params: string[]) {\n            const paths = await OS.Util.loadArgs(params, this.options, this.options);\n            try {\n                await this.run(paths)\n            } catch (e) {\n                this.error(e);\n            }\n            console.log(paths);\n            OS.Process.end();\n        }\n\n        async run(paths: string[]) {\n\n            this.files = await this.readFiles(paths);\n\n            console.log(this.files);\n            if (this.options.follow) {\n\n            } else {\n                OS.Process.end();\n            }\n        }\n\n        async readFiles(paths: string[]) {\n            const files: { [s: string]: string | null } = {};\n            for (let i = 0; i < paths.length; i++) {\n                const path = paths[i];\n                files[path] = await OS.FS.read(path);\n            }\n            return files;\n        }\n    }\n\n    new Tail(PROCESS);\n};\n\nexport default tail;","export default class Main {\n    str: string;\n    constructor(str: string) {\n        this.str = str;\n    }\n}","export default class Main {\n    bob: number = 1;\n}","import FS, { createRoot } from \"./Services/FileSystem\";\nimport Identity from \"./Struct/Identity\";\nimport ProcessManager from \"./Services/ProcessManager\";\nimport Display from \"./Services/Display\";\nimport { DefaultApps } from \"./App/Default/index\";\n\nconst rootIdent: Identity = new Identity(\"root\", [], \"/\");\nconst guestIdent: Identity = new Identity(\"guest\", [], \"/home/guest\");\n\nconst InIframe: Function = (): boolean => {\n    try {\n        return window.self !== window.top;\n    } catch (e) {\n        return true;\n    }\n};\n\nconst isRemote: boolean = InIframe();\n\ncreateRoot(rootIdent);\n\nFS.mkdir(\"/bin\", rootIdent);\n\nFS.mkdir(\"/home\", rootIdent);\n\n// guest home\nFS.mkdir(\"/home/guest\", rootIdent)\n    .then(() => {\n        FS.chown(\"/home/guest\", rootIdent, \"guest\", \"guest\")\n            .then(() => {\n                FS.mkdir(\"/home/guest/bin\", guestIdent);\n                // tslint:disable-next-line\n                FS.write(\"/home/guest/test\", \"Lorem ipsum dolor sit amet, consectetur \\n\\n\\n\\n\\n\\n\\n adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\", guestIdent);\n                FS.mkdir(\"/home/guest/bin\", guestIdent);\n            });\n    });\n\n// root home\nFS.mkdir(\"/home/root\", rootIdent);\n\nObject.entries(DefaultApps).map((app: Array<any>) => {\n    FS.write(\"bin/\" + app[0], app[1].toString(), rootIdent);\n    FS.chmod(\"bin/\" + app[0], rootIdent, \"755\");\n});\n\n\nconst display: Display = new Display();\nconst processManager: ProcessManager = new ProcessManager();\n\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    console.log(location.host, isRemote);\n\n    display.init(processManager);\n    processManager.init(display);\n\n    display.output([\n        [\"Welcome to wlf.io TSPseudoOS v0.1 LTNS(Little To No Support)\"],\n        [\"\"],\n        [\"  * Try the command help to see what you can do\"],\n        [\"\"],\n        [\"Last Login: Fri, 25 Oct 2019 18: 57: 47 GMT\"],\n    ], 0, true);\n\n    processManager.startProcess(\"bash\", [], guestIdent);\n});\n","import FS from \"./FileSystem\";\n// import Process from \"../Struct/Process\";\nimport Identity, { IIdentity } from \"../Struct/Identity\";\n// import { IDisplayItem, AppMessage, AppMessageType } from \"../App/libOS\";\nimport { IDisplay, StubDisplay } from \"./Display\";\nimport Process from \"../Struct/Process\";\n\ninterface IPendingApp {\n    args: Array<any>;\n    resolve: Function;\n    reject: Function;\n}\n\nexport interface IProcessManager {\n    display: IDisplay | null;\n    stdIn(source: string | number, data: any): void;\n    startProcess(exec: string, params: string[], identity: Identity | null, parent?: any): Promise<any>;\n    getDisplay(): IDisplay;\n    setEnv(pid: number, name: string, value: string): Promise<any>;\n}\n\nexport default class ProcessManager implements IProcessManager {\n    display: IDisplay | null = null;\n    processes: { [s: number]: Process } = {};\n    pids: number = 0;\n    pending: IPendingApp[] = [];\n    libJS: string | null = null;\n\n    mainProcess: Process | null = null;\n\n    // constructor() {\n    // }\n\n    // OS: { [s: string]: { [s: string]: Function } } = {\n    //     FS: {\n    //         list: (process: Process, data: string) => FS.list(data, process),\n    //         mkdir: (process: Process, data: string) => FS.mkdir(data, process),\n    //         resolve: (process: Process, data: string[]) => FS.resolveWorkingPaths(data, process),\n    //         append: (process: Process, data: { path: string, content: string }) => FS.append(data.path, data.content, process),\n    //         write: (process: Process, data: { path: string, content: string }) => FS.write(data.path, data.content, process),\n    //         touch: (process: Process, path: string) => FS.touch(path, process),\n    //         read: (process: Process, path: string) => FS.read(path, process),\n    //         del: (process: Process, path: string) => FS.del(path, process),\n    //         dirExists: (process: Process, path: string) => FS.dirExists(path, process),\n    //         fileExists: (process: Process, path: string) => FS.fileExists(path, process),\n    //         delDir: (process: Process, path: string) => FS.delDir(path, process),\n    //     },\n    //     Process: {\n    //         end: (process: Process) => process.kill(),\n    //         setSelf: (process: Process, data: { prop: string, value: any }) => process.set(data.prop, data.value),\n    //         self: (process: Process) => Promise.resolve(process.data()),\n    //         start: (process: Process, data: any) => this.startProcess(data.exec, data.params, null, process),\n    //         crash: (process: Process, error: any) => { this.OS.Std.out(process, error); process.kill(); },\n    //         changeWorkingDir: (process: Process, data: any) => this.changeWorkingDir(data, process),\n    //     },\n    //     Std: {\n    //         out: (process: Process, data: any) =>\n    //             process.hasParent() ? process.intoParent(data) : this.OS.Out.print({ data: data, over: 0 }),\n    //         prompt: (process: Process, text: string) => {\n    //             if (this.mainProcess !== null && this.mainProcess.id === process.id && this.display !== null) {\n    //                 this.display.setText(text);\n    //             }\n    //         },\n    //         in: (process: Process, data: any) => process.intoChild(data.pid, data.data, data.source || null),\n    //     },\n    //     Out: {\n    //         print: (item: IDisplayItem) => this.output(item.data, item.over, false),\n    //         printLn: (item: IDisplayItem) => { console.log(item); return this.output(item.data, item.over, true); },\n    //     },\n    //     Display: {\n    //         info: () => this.display !== null ? this.display.info() : Promise.reject(new Error(\"PM Error : missing display : ...\")),\n    //     },\n    //     Remote: {\n    //         connect: (process: Process, address: string) => this.log(process.identifier(), [\"Remote\", \"connect\"], address),\n    //         disconnect: (process: Process, id: number) => this.log(process.identifier(), [\"Remote\", \"disconnect\"], id),\n    //         in: (process: Process, data: any) => this.log(process.identifier(), [\"Remote\", \"stdIn\"], data),\n    //     }\n    // };\n\n    setEnv(pid: number, name: string, value: string): Promise<any> {\n        if (this.processes.hasOwnProperty(pid)) {\n            this.processes[pid].setEnv(name, value);\n            return Promise.resolve();\n        }\n        return Promise.reject();\n    }\n\n    init(display: IDisplay): void {\n        this.display = display;\n    }\n\n    killProcess(processID: number): void {\n        const process: Process | null = this.getProcessFromID(processID);\n        if (process !== null) {\n            process.kill();\n        }\n    }\n\n    stdIn(source: string | number, data: any): void {\n        if (this.mainProcess !== null) {\n            this.mainProcess.stdIn(source, data);\n        } else {\n            console.log(\"STDIN\", data);\n        }\n    }\n\n    async startProcess(exec: string, params: string[], identity: IIdentity | null, parent?: Process): Promise<any> {\n        if (!(identity instanceof Identity)) {\n            if (parent instanceof Process) {\n                identity = parent.getIdentity();\n            }\n        }\n\n        if (!(identity instanceof Identity)) {\n            throw new Error(\"Identity is not identity\");\n        }\n\n        params = params.filter(s => s.length > 0);\n\n        try {\n            const execData: [string, string] = await FS.execRead(exec, identity);\n            this.pids++;\n            const execPath: string = execData[0];\n            const code: string = execData[1].trim();\n            const proc: Process = new Process(this, execPath, this.pids, params, identity, parent);\n            proc.start(code);\n\n            this.processes[this.pids] = proc;\n\n            if (this.mainProcess === null) {\n                this.mainProcess = proc;\n            }\n            return proc;\n        } catch (e) {\n            console.log([\"Process Error\", e]);\n            return Promise.reject([\"Process Error\", e]);\n        }\n    }\n\n    private getProcessFromID(id: number): Process | null {\n        return Object.values(this.processes).find(p => p.id === id) || null;\n    }\n\n    getDisplay(): IDisplay {\n        if (this.display !== null) {\n            return this.display;\n        }\n        return new StubDisplay();\n    }\n\n}"],"sourceRoot":""}