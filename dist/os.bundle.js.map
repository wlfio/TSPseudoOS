{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/Services/FileSystem.ts","webpack:///./src/Struct/Identity.ts","webpack:///./src/Services/Display.ts","webpack:///./src/app.ts","webpack:///./src/Services/ProcessManager.ts","webpack:///./src/Struct/Process.ts","webpack:///./src/Struct/OSLib.ts","webpack:///./src/Struct/Util.ts","webpack:///./src/Services/Cmd.ts","webpack:///./src/App/Default/index.ts","webpack:///./src/App/Default/ls.ts","webpack:///./src/App/Default/shell.ts","webpack:///./src/App/Default/mkdir.ts","webpack:///./src/App/Default/cat.ts","webpack:///./src/App/Default/touch.ts","webpack:///./src/App/Default/rm.ts","webpack:///./src/App/Default/cd.ts","webpack:///./src/App/Default/tail.ts","webpack:///./src/App/Default/head.ts","webpack:///./src/App/Default/edit.ts","webpack:///./src/App/Default/help.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","slashWrap","path","charAt","length","fixPath","split","reduce","out","inp","slice","join","filePath","indexOf","dirPath","permPath","owndPath","getPathOwners","localStorage","getItem","getPathOwnerString","getPathUsr","getPermBits","parseInt","permStringPart","action","ps","permString","perms","getPermBitsUsr","getPermBitsGrp","getPermBitsAny","groupHasPermission","identity","groups","includes","getPathGrp","hasPermission","user","priveledged","userHasPermission","anyHasPermission","getFileName","pop","getFileExt","parts","isDir","createRoot","doMkdir","isDirCheck","console","trace","Error","getFileDir","hasPermissionCheck","hasDirPermissionCheck","dirExistsCheck","doFileExists","fileExists","identC","getIdentity","resolvePath","Promise","resolve","fileExistsCheck","dirExists","identitC","resolveWorkingPath","working","trim","check","replace","workingDir","dirAccessCheck","resolveWorkingPaths","paths","map","doChmod","usr","grp","any","setItem","toString","chmod","hex","e","reject","doChown","group","chown","permBitRead","mkdir","fileDirExistsCheck","fileNotExistsCheck","write","content","exists","doWrite","touch","doRead","read","append","newContent","then","wrt","catch","del","removeItem","doDel","delDir","keys","forEach","startsWith","doDelDir","list","f","filter","file","getChildren","rootPath","entry","dir","ownerData","full","ext","permBytes","size","Blob","listEntry","sort","a","b","getExec","exec","getEnv","resolveExecPaths","str","cleanSlash","execRead","data","Identity","env","this","toLowerCase","setEnv","Array","fallback","clone","priveleged","ident","setPriveledged","entries","pm","log","text","over","newLine","queuedItems","processManager","display","document","createElement","input","createDisplay","addEventListener","activeElement","focus","ev","ctrlKey","repeat","controlKey","enterText","tabKey","preventDefault","history","processQueue","txt","span","colours","setAttribute","textContent","elements","index","array","colourizeText","push","insertBefore","level","type","reduceArrayForDisplay","processDisplayData","items","breakUptext","writeToDisplay","scrollToBottom","scrollTo","scrollHeight","show","item","id","tabIndex","classList","add","contentEditable","spellcheck","body","querySelector","specialUserInput","inputOutput","range","createRange","Range","sel","window","getSelection","Selection","childs","childNodes","setStart","collapse","removeAllRanges","addRange","userInput","setText","output","stdIn","rootIdent","guestIdent","isRemote","self","top","InIframe","DefaultApps","app","location","host","init","startProcess","processes","pids","pending","libJS","mainProcess","pid","processID","process","getProcessFromID","kill","source","params","parent","execData","execPath","code","proc","res","start","values","find","StubDisplay","Process","manager","dead","children","parentInCB","parentEndCB","parentID","api","Std","hasParent","intoParent","Display","print","in","intoChild","FS","end","prop","crash","error","changeWorkingPath","prompt","getDisplay","printLn","info","lib","signature","identifier","cbs","registerChild","event","wrapper","eval","service","func","dat","removeChild","from","fireEvent","endProcess","hooks","awaitProcs","cb","hookEvent","msg","startAndAwaitOutput","startAndAwait","printRaw","Util","CMD","_call","fireHooks","awaitIn","loadArgs","args","opts","remain","arg","JSON","stringify","j","shrt","bytesToHuman","bytes","kibi","bits","step","set","Math","round","hexCheck","test","testColourHex","Colours","red","green","blue","black","white","lightBlue","Colourize","fore","back","toUpperCase","ls","shell","cat","rm","cd","tail","head","edit","help","OS","all","human","long","raw","count","done","argMap","h","G","formatFileName","arr","longOutputEntry","result","longOutput","shortOutput","bashHistoryFile","origin","activeProcessID","activeOutputed","subProcs","historyPosition","bashProcess","selfUpdate","pos","min","max","setHistoryPosition","getPromptPath","match","printPrompt","getSubProc","splitUserInput","dirs","ctrlCode","showHistory","tabComplete","specialCode","shift","er","message","newHistory","resolveAppIn","version","options","verbose","parents","optMap","v","breakPathIntoParentPaths","rawPaths","prefix","broken","breakPathsIntoParentPaths","make","number","lines","empty","line","splitLines","firstOut","run","printOutput","recursive","printDirError","follow","files","readFiles","PROCESS","bob"],"mappings":"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","file":"os.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","import { IIdentity, IIdentityContainer } from \"../Struct/Identity\";\n\nconst dirString: string = \"___dir___\";\n\nconst cleanSlash: Function = (str: string) => str.replace(/\\//g, \"\");\n\nconst slashWrap: Function = (path: string): string => {\n    if (path.charAt(0) !== \"/\") {\n        path = \"/\" + path;\n    }\n    if (path.charAt(path.length - 1) !== \"/\") {\n        path += \"/\";\n    }\n    return path;\n};\n\nconst fixPath: Function = (path: string) => {\n    return \"/\" + path.split(\"/\").reduce((out: string[], inp: string) => {\n        if (inp.length > 0 && inp !== \".\") {\n            if (inp === \"..\") {\n                return out.slice(0, out.length - 1);\n            } else {\n                return [...out, inp];\n            }\n        }\n        return out;\n    }, []).join(\"/\");\n};\n\nconst filePath: Function = (path: string) => path.indexOf(\"FSF:\") !== 0 ? \"FSF:\" + fixPath(path) : path;\nconst dirPath: Function = (path: string) => path.indexOf(\"FSD:\") !== 0 ? \"FSD:\" + fixPath(path) : path;\nconst permPath: Function = (path: string) => path.indexOf(\"FSP:\") !== 0 ? \"FSP:\" + fixPath(path) : path;\nconst owndPath: Function = (path: string) => path.indexOf(\"FSO:\") !== 0 ? \"FSO:\" + fixPath(path) : path;\n\n\nconst getPathOwnerString: Function = (path: string): string => localStorage.getItem(owndPath(path)) || \"nobody:nobody\";\nconst getPathOwners: Function = (path: string): string[] => getPathOwnerString(path).split(\":\");\nconst getPathUsr: Function = (path: string) => getPathOwners(path)[0];\nconst getPathGrp: Function = (path: string) => getPathOwners(path)[1];\n\n\nconst permBitRead: number = 4;\nconst permBitWrit: number = 2;\nconst permBitExec: number = 1;\n\nconst bitOffsetUsr: number = 8;\nconst bitOffsetAny: number = 0;\nconst bitOffsetGrp: number = 4;\n\nconst getPermBits: Function = (path: string): number => parseInt(localStorage.getItem(permPath(path)) || \"\", 16);\n\n// tslint:disable: no-bitwise\n\nconst permStringPart: Function = (action: number): string => {\n    let ps: string = \"\";\n    ps += (action & permBitRead) ? \"r\" : \"-\";\n    ps += (action & permBitWrit) ? \"w\" : \"-\";\n    ps += (action & permBitExec) ? \"x\" : \"-\";\n    return ps;\n};\n\nconst permString: Function = (perms: number): string => {\n    return permStringPart(perms >> bitOffsetUsr)\n        + permStringPart(perms >> bitOffsetGrp)\n        + permStringPart(perms >> bitOffsetAny);\n};\n\nconst getPermBitsUsr: Function = (path: string): number => getPermBits(path) >> bitOffsetUsr;\nconst getPermBitsGrp: Function = (path: string): number => getPermBits(path) >> bitOffsetGrp;\nconst getPermBitsAny: Function = (path: string): number => getPermBits(path) >> bitOffsetAny;\n\nconst userHasPermission: Function = (path: string, action: number, identity: IIdentity) => {\n    const user: string = identity.user;\n    if (identity.priveledged) {\n        if (action & permBitExec) {\n            return (\n                (getPermBitsUsr(path) & permBitExec)\n                ||\n                (getPermBitsGrp(path) & permBitExec)\n                ||\n                (getPermBitsAny(path) & permBitExec)\n            );\n        }\n        return true;\n    }\n    if (user === getPathUsr(path) && getPermBitsUsr(path) & action) {\n        return true;\n    }\n    return false;\n};\n\nconst groupHasPermission: Function = (path: string, action: number, identity: IIdentity) => {\n    const groups: string[] = identity.groups;\n    if (groups.includes(getPathGrp(path)) && getPermBitsGrp(path) & action) {\n        return true;\n    }\n    return false;\n};\n\nconst anyHasPermission: Function = (path: string, action: number): boolean => {\n    if (getPermBitsAny(path) & action) {\n        return true;\n    }\n    return false;\n};\n// tslint:enable: no-bitwise\n\n\nconst hasPermission: Function = (path: string, action: number, identity: number) => {\n    return (\n        userHasPermission(path, action, identity)\n        ||\n        groupHasPermission(path, action, identity)\n        ||\n        anyHasPermission(path, action)\n    );\n};\n\n\nconst getFileName: Function = (path: string): string => path.split(\"/\").pop() || \"\";\n\nconst getFileExt: Function = (path: string): string => {\n    const parts: string[] = getFileName(path).split(\".\");\n    return parts.length > 1 ? parts.pop() || \"\" : \"\";\n};\n\nconst isDir: Function = (path: string) => {\n    if (path.length < 1 || path === \"/\") {\n        path = \"/\";\n    }\n    return localStorage.getItem(dirPath(path)) === dirString;\n};\n\nexport const createRoot: Function = (identity: IIdentity): void => {\n    doMkdir(\"/\", identity);\n}\n\nconst isDirCheck: Function = (path: string) => {\n    if (!isDir(path)) {\n        console.trace();\n        throw new Error([\"Access Error\", \"Path is not directory\", path].join(\" : \"));\n    }\n};\n\nconst getFileDir: Function = (path: string): string => {\n    const parts: string[] = path.split(\"/\");\n    path = parts.slice(0, parts.length - 1).join(\"/\");\n    return path;\n};\n\n\nconst hasPermissionCheck: Function = (path: string, action: number, identity: IIdentity) => {\n    if (!hasPermission(path, action, identity)) {\n        throw new Error([\"Permissions Error\", \"Denied \" + permStringPart(action), path].join(\" : \"));\n    }\n};\nconst hasDirPermissionCheck: Function = (path: number, action: number, identity: number) =>\n    hasPermissionCheck(getFileDir(path), action, identity);\n\nconst dirAccessCheck: Function = (path: string, identity: IIdentity) => {\n    path = getFileDir(path);\n    const parts: string[] = path.split(\"/\");\n    for (let i: number = 2; i <= parts.length; i++) {\n        const p: string = parts.slice(0, i).join(\"/\");\n        isDirCheck(p);\n        hasPermissionCheck(p, permBitExec, identity);\n    }\n};\n\n\n\nconst dirExistsCheck: Function = (path: string) => {\n    if (!isDir(path)) {\n        throw new Error([\"Access Error\", \"Cannot access '\" + path + \"': No such file or directory\", path].join(\" : \"));\n    }\n};\n\nconst doFileExists: Function = (path: string): boolean => {\n    return localStorage.getItem(filePath(path)) !== null;\n};\n\nexport const fileExists: Function = (path: string, identC: IIdentityContainer) => {\n    const identity: IIdentity = identC.getIdentity();\n    path = resolvePath(path, identity);\n    return Promise.resolve(doFileExists(path));\n}\n\nconst fileDirExistsCheck: Function = (path: string): void => {\n    path = getFileDir(path);\n    isDirCheck(path);\n};\n\n\nconst fileExistsCheck: Function = (path: string) => {\n    if (!doFileExists(path)) {\n        console.trace();\n        throw new Error([\"Access Error\", \"Cannot access '\" + path + \"': No such file\", path].join(\" : \"));\n    }\n};\n\nconst fileNotExistsCheck: Function = (path: string) => {\n    if (doFileExists(path)) {\n        throw new Error([\"Access Error\", \"Path exists\", path].join(\" : \"));\n    }\n};\n\nexport const dirExists: Function = (path: string, identitC: IIdentityContainer) => {\n    const identity: IIdentity = identitC.getIdentity();\n    path = resolvePath(path, identity);\n    return Promise.resolve(isDir(path));\n};\n\nconst resolveWorkingPath: Function = (path: string, working: string): string => {\n    working = slashWrap(working || \"/\");\n    path = path.trim();\n    if (path.charAt(0) !== \"/\") {\n        path = working + path;\n    }\n    path = fixPath(path);\n    return path;\n};\n\nconst resolvePath: Function = (path: string, identity: IIdentity, check?: boolean): string => {\n    check = check !== false;\n    path = path.trim();\n    if (path.charAt(0) === \"~\") {\n        path = path.replace(\"~\", \"/home/\" + identity.user + \"/\");\n    }\n    path = resolveWorkingPath(path, identity.workingDir);\n    if (check) {\n        dirAccessCheck(path, identity);\n    }\n    return path;\n};\n\nexport const resolveWorkingPaths: Function = (paths: string[], identitC: IIdentityContainer): Promise<string[]> => {\n    return Promise.resolve(paths.map(p => resolvePath(p, identitC.getIdentity(), false)));\n};\n\nconst resolveExecPaths: Function = (exec: string, identity: IIdentity): string[] => {\n    return [\n        resolvePath(exec, identity),\n        ...identity.getEnv(\"path\", \"/bin\").split(\";\").map(p => resolveWorkingPath(exec, p))\n    ];\n};\n\n\n\n\n\n// tslint:disable:no-bitwise\nconst doChmod: Function = (path: string, usr: number, grp: number, any: number) => {\n    let perms: number = 0;\n    perms |= (usr << bitOffsetUsr);\n    perms |= (grp << bitOffsetGrp);\n    perms |= (any << bitOffsetAny);\n    localStorage.setItem(permPath(path), \"0x\" + perms.toString(16));\n};\n// tslint:enable:no-bitwise\n\nexport const chmod: Function = (path: string, identitC: IIdentityContainer, hex: string) => {\n    try {\n        const identity: IIdentity = identitC.getIdentity();\n        path = resolvePath(path, identity);\n        fileExistsCheck(path);\n        if (typeof hex !== \"string\" || hex.length !== 3) {\n            throw new Error([\"FS Error\", \"\" + hex, \"must be 3 digits long\"].join(\" : \"));\n        }\n        const grp: number = parseInt(\"0x\" + hex.charAt(1), 16);\n        const usr: number = parseInt(\"0x\" + hex.charAt(0), 16);\n        const any: number = parseInt(\"0x\" + hex.charAt(2), 16);\n        if (identity.priveledged || getPathUsr(path) === identity.user) {\n            return Promise.resolve(doChmod(path, usr, grp, any));\n        }\n        throw new Error([\"FS ERROR\", path, \"Permissions can only be changed by root or owner\"].join(\" : \"));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nconst doChown: Function = (path: string, identity: IIdentity, user?: string, group?: string) => {\n    localStorage.setItem(owndPath(path), [user || identity.user, group || identity.user].join(\":\"));\n};\n\nexport const chown: Function = (path: string, identitC: IIdentityContainer, user?: string, group?: string) => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        dirExistsCheck(path);\n        if (identity.priveledged) {\n            return Promise.resolve(doChown(path, identity, user, group));\n        }\n        throw new Error([\"FS Error\", \"chown\", \"requires root\"].join(\" : \"));\n    } catch (e) {\n        Promise.reject(e);\n    }\n};\n\n\nconst doMkdir: Function = (path: string, identity: IIdentity): boolean => {\n    if (isDir(path)) {\n        return false;\n    }\n    localStorage.setItem(dirPath(path), dirString);\n    // tslint:disable-next-line:no-bitwise\n    doChmod(path, permBitRead | permBitWrit | permBitExec, permBitRead | permBitExec, permBitRead | permBitExec);\n    doChown(path, identity);\n    return true;\n};\n\nexport const mkdir: Function = (path: string, identitC: IIdentityContainer): Promise<boolean> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        if (isDir(path)) {\n            return Promise.resolve(false);\n        }\n        fileDirExistsCheck(path);\n        fileNotExistsCheck(path);\n        hasDirPermissionCheck(path, permBitWrit, identity);\n        return Promise.resolve(doMkdir(path, identity));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nconst doWrite: Function = (path: string, content: string, exists: boolean, identity: IIdentity) => {\n    exists = exists === true;\n    localStorage.setItem(filePath(path), content);\n    if (!exists) {\n        // tslint:disable-next-line:no-bitwise\n        doChmod(path, permBitRead | permBitWrit, permBitRead, permBitRead);\n        doChown(path, identity);\n    }\n    return [path, content];\n};\n\nexport const write: Function = (path: string, content: string, identitC: IIdentityContainer): Promise<string[]> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        const exists: boolean = doFileExists(path);\n        if (exists) {\n            hasPermissionCheck(path, permBitWrit, identity);\n        } else {\n            hasDirPermissionCheck(path, permBitWrit, identity);\n        }\n        return Promise.resolve(doWrite(path, content, exists, identity));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\nexport const touch: Function = (path: string, identitC: IIdentityContainer): Promise<string[]> => write(path, \"\", identitC);\n\nconst doRead: Function = (path: string): string | null => localStorage.getItem(filePath(path));\n\nexport const read: Function = (path: String, identitC: IIdentityContainer): Promise<string | null> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        fileExistsCheck(path);\n        hasPermissionCheck(path, permBitRead, identity);\n        return Promise.resolve(doRead(path));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nexport const append: Function = (path: string, newContent: string, identitC: IIdentityContainer): Promise<string[]> => {\n    return new Promise((resolve, reject) => {\n        read(path, identitC)\n            .then((content: string | null) => {\n                content = content || \"\";\n                content += newContent;\n                write(path, content, identitC)\n                    .then((wrt: string[]) => {\n                        resolve(wrt);\n                    }).catch((e: any) => {\n                        reject(e);\n                    });\n            })\n            .catch(() => {\n                write(path, newContent, identitC)\n                    .then((wrt: string[]) => {\n                        resolve(wrt);\n                    }).catch((e: any) => {\n                        reject(e);\n                    });\n            });\n    });\n};\n\nconst doDel: Function = (path: string): string => {\n    localStorage.removeItem(filePath(path));\n    localStorage.removeItem(permPath(path));\n    localStorage.removeItem(owndPath(path));\n    return path;\n};\n\nexport const del: Function = (path: string, identitC: IIdentityContainer): Promise<string> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        hasDirPermissionCheck(path, permBitWrit, identity);\n        fileExistsCheck(path);\n        return Promise.resolve(doDel(path));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\n\nconst doDelDir: Function = (path: string) => {\n    Object.keys(localStorage).forEach(p => {\n        const s: string = p.slice(4);\n        if (s.startsWith(path)) {\n            localStorage.removeItem(p);\n        }\n    });\n}\n\n\nexport const delDir: Function = (path: string, identitC: IIdentityContainer): Promise<string> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        hasDirPermissionCheck(path, permBitWrit, identity);\n        dirExistsCheck(path);\n        return Promise.resolve(doDelDir(path));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nconst getChildren: Function = (path: string): Array<IFSListEntrySpawn> => {\n    path = slashWrap(path);\n    let f: string = filePath(path);// + \"/\";\n    let d: string = dirPath(path);// + \"/\";\n    const l: number = path.split(\"/\").length;\n    return Object.keys(localStorage)\n        .filter(p => p.startsWith(f) || p.startsWith(d))\n        .filter(p => p.split(\"/\").length <= l)\n        .map(p => {\n            const parts: string[] = p.split(\":\");\n            return { file: parts[0] === \"FSF\", path: parts[1] };\n        });\n};\n\ninterface IFSListEntrySpawn {\n    file: boolean;\n    path: string;\n}\n\nconst listEntry: Function = (rootPath: string, entry: IFSListEntrySpawn): IFSListEntry => {\n    const dir: boolean = !entry.file;\n    const path: string = entry.path;\n    const ownerData: string[] = getPathOwners(path);\n    const perms: number = getPermBits(path);\n    return {\n        full: path,\n        path: getFileDir(path),\n        name: rootPath === path ? \".\" : getFileName(path),\n        ext: !dir ? getFileExt(path) : \"\",\n        file: !dir,\n        user: ownerData[0],\n        group: ownerData[1],\n        permBytes: perms,\n        perms: (dir ? \"d\" : \"-\") + permString(perms),\n        size: dir ? 0 : new Blob([doRead(path)]).size,\n    };\n};\n\nexport const list: Function = (path: string, identitC: IIdentityContainer): Promise<IFSListEntry[]> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        path = resolvePath(path, identity);\n        dirExistsCheck(path);\n        hasPermissionCheck(path, permBitRead, identity);\n        let paths: Array<IFSListEntry> = getChildren(path);\n        paths = paths.map((p: IFSListEntrySpawn) => listEntry(path, p));\n        paths = paths.sort((a: IFSListEntry, b: IFSListEntry) => a.full < b.full ? -1 : (a.full > b.full ? 1 : 0));\n        return Promise.resolve(paths);\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nexport interface IFSListEntry {\n    full: string;\n    path: string;\n    name: string;\n    ext: string;\n    file: boolean;\n    user: string;\n    group: string;\n    permBytes: number;\n    perms: string;\n    size: number;\n}\n\nexport const getExec: Function = (exec: string, identitC: IIdentityContainer): Promise<string> => {\n    const identity: IIdentity = identitC.getIdentity();\n    try {\n        exec = cleanSlash(exec);\n        const paths: string[] = resolveExecPaths(exec, identity);\n        for (let i: number = 0; i < paths.length; i++) {\n            const path: string = paths[i];\n            if (doFileExists(path)) {\n                if (hasPermission(path, permBitExec, identity)) {\n                    return Promise.resolve(path);\n                }\n            }\n        }\n        throw new Error([\"FS Error\", exec, \"Not found\"].join(\" : \"));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\n\nexport const execRead: Function = (exec: string, identitC: IIdentityContainer): Promise<[string, string]> => {\n    const identity: IIdentity = identitC.getIdentity();\n    return new Promise((resolve, reject) => {\n        getExec(exec, identity)\n            .then((path: string) => {\n                read(path, identity)\n                    .then((data: string) => resolve([path, data]))\n                    .catch((e: any) => reject(e));\n            })\n            .catch((e: any) => reject(e));\n    });\n};\n\n\n\nexport default {\n    read,\n    write,\n    del,\n    delDir,\n    list,\n    touch,\n    mkdir,\n    getExec,\n    execRead,\n    chmod,\n    chown,\n    resolveWorkingPaths,\n    append,\n    dirExists,\n    fileExists,\n};","import FS, { IFSListEntry } from \"../Services/FileSystem\";\n\n\nexport interface IIdentityContainer {\n    getIdentity(): IIdentity;\n}\n\nexport interface IIdentity extends IIdentityContainer {\n    user: string;\n    groups: string[];\n    workingDir: string;\n    priveledged: boolean;\n    getEnv(name: string, fallback?: string): string;\n    setEnv(name: string, value: string | string[]): void;\n    changeWorkingPath(path: string): Promise<boolean>;\n}\n\nexport default class Identity implements IIdentity {\n    user: string;\n    groups: string[];\n    workingDir: string;\n    priveledged: boolean;\n    env: { [s: string]: string } = {};\n\n    constructor(user: string, groups: Array<String>, workingDir: string) {\n        groups = groups || [];\n        workingDir = workingDir || \"/\";\n\n        this.user = user.toLowerCase();\n        this.groups = [...groups, this.user]\n            .filter((e, i, a) => a.indexOf(e) === i)\n            .map(e => e.toLowerCase());\n        this.workingDir = workingDir;\n        this.priveledged = this.user === \"root\";\n        this.setEnv(\"path\", [\"/bin\"]);\n    }\n\n    setEnv(name: string, value: string | string[]): void {\n        if (value instanceof Array) {\n            value = value.join(\";\");\n        }\n        this.env[name] = value;\n    }\n\n    getEnv(name: string, fallback?: string): string {\n        if (this.env.hasOwnProperty(name)) {\n            return this.env[name];\n        }\n        return fallback || \"\";\n    }\n\n    getIdentity(): IIdentity {\n        return this.clone();\n    }\n\n    setPriveledged(priveleged: boolean): void {\n        this.priveledged = priveleged;\n    }\n\n    async changeWorkingPath(path: string): Promise<boolean> {\n        try {\n            const exists: IFSListEntry[] = await FS.list(path, this);\n            if (exists instanceof Array) {\n                this.workingDir = path;\n                return Promise.resolve(true);\n            }\n        } catch (e) {\n            return Promise.reject(e);\n        }\n        return Promise.resolve(false);\n    }\n\n    clone(): Identity {\n        const ident: Identity = new Identity(this.user + \"\", [...this.groups], this.workingDir + \"\");\n        ident.setPriveledged(this.priveledged === true);\n        Object.entries(this.env).forEach((entry: [string, string]) => {\n            ident.setEnv(entry[0], entry[1]);\n        });\n        return ident;\n    }\n}","import { IProcessManager } from \"./ProcessManager\";\n\ninterface IQueuedDisplayItem {\n    text: any[];\n    over: number;\n}\n\nexport interface IDisplay {\n    init(pm: IProcessManager): void;\n    setText(text: string): Promise<any>;\n    output(data: any, over?: number, newLine?: boolean): Promise<any>;\n    info(): Promise<any>;\n}\n\nexport class StubDisplay implements IDisplay {\n    init(pm: IProcessManager): void {\n        console.log(\"STUB DISPLAY INIT\", pm);\n    }\n    setText(text: string): Promise<any> {\n        console.log(\"STUB DISPLAY SET TEXT\", text);\n        return Promise.resolve();\n    }\n    output(data: any, over?: number, newLine?: boolean): Promise<any> {\n        console.log(\"STUB DISPLAY OUTPUT\", data, over, newLine);\n        return Promise.resolve();\n    }\n    info(): Promise<any> {\n        console.log(\"STUB DISPLAY INFO\");\n        return Promise.resolve({});\n    }\n}\n\nexport default class Display implements IDisplay {\n    display: HTMLDivElement;\n    input: HTMLSpanElement;\n\n    queuedItems: IQueuedDisplayItem[] = [];\n\n    processManager: IProcessManager | null = null;\n\n    constructor() {\n        this.display = document.createElement(\"div\");\n        this.input = document.createElement(\"span\");\n    }\n\n    info(): Promise<any> {\n        return Promise.resolve({});\n    }\n\n    init(processManager: IProcessManager): void {\n        this.processManager = processManager;\n        this.createDisplay();\n        document.addEventListener(\"keydown\", () => {\n            if (document.activeElement !== this.input) {\n                this.input.focus();\n            }\n        });\n\n        this.input.addEventListener(\"keydown\", (ev: KeyboardEvent) => {\n            if (ev.ctrlKey && ev.key !== \"Control\" && !ev.repeat && ev.key !== \"F5\") {\n                this.controlKey(ev.key);\n            } else if ((ev.key === \"ArrowUp\" || ev.key === \"ArrowDown\") && !ev.repeat) {\n                this.history(ev.key === \"ArrowDown\" ? -1 : 1);\n            } else if (ev.key === \"Enter\") {\n                if (!ev.repeat) {\n                    this.enterText();\n                }\n            } else if (ev.key === \"Tab\") {\n                this.tabKey();\n                console.log(\"TAB KEY\");\n                ev.preventDefault();\n            } else {\n                return;\n            }\n            ev.preventDefault();\n        });\n        this.processQueue();\n    }\n\n    private colourizeText(text: string): HTMLElement[] {\n        const segments: string[] = text.split(/(?=[0-9A-F]{6})/);\n        return segments.map((txt: string): HTMLElement => {\n            const span: HTMLSpanElement = document.createElement(\"span\");\n            if (txt.startsWith(\"\")) {\n                const colours: String = txt.slice(0, 7);\n                span.setAttribute(\"style\", \"color:#\" + colours.slice(1, 4) + \";background-color:#\" + colours.slice(4, 7) + \";\");\n                txt = txt.slice(7);\n            }\n            span.textContent = txt;\n            return span;\n        });\n    }\n\n    private breakUptext(text: string): HTMLElement[] {\n        const elements: HTMLElement[] = [];\n\n        text.split(\"\\n\").forEach((t: string, index: number, array: string[]) => {\n            const span: HTMLSpanElement = document.createElement(\"span\");\n            this.colourizeText(t).forEach((e: HTMLElement) => {\n                span.append(e);\n            });\n            elements.push(span);\n            if (index < (array.length - 1)) {\n                elements.push(document.createElement(\"br\"));\n            }\n        });\n\n        return elements;\n    }\n\n\n    private writeToDisplay(text: any[], over?: number): void {\n        over = over || 0;\n        text.map((e) => {\n            this.display.insertBefore(e, this.input);\n        });\n    }\n\n    private reduceArrayForDisplay(data: Array<any>, level: number): string {\n        return data.reduce((out: string, inp: any, index: number) => {\n            const type: string = typeof inp;\n            if (type === \"string\" || type === \"number\") {\n                out += (index < 1 ? \"\" : \"\\t\") + inp;\n            } else {\n                if (inp instanceof Array) {\n                    out += (index < 1 ? \"\" : \"\\n\") + this.reduceArrayForDisplay(inp, level + 1);\n                }\n            }\n            return out;\n        }, \"\");\n    }\n\n    private processDisplayData(data: any): string {\n        if (data instanceof Array) {\n            return this.reduceArrayForDisplay(data, 0);\n        }\n        console.log(data);\n        return \"FAILED TO CONVERT FOR DISPLAY\";\n    }\n\n    output(data: any, over?: number, newLine?: boolean): Promise<any> {\n        newLine = newLine === true;\n        let text: string = \"\";\n        if (typeof data !== \"string\") {\n            text = this.processDisplayData(data);\n        } else {\n            text = data;\n        }\n        const items: HTMLElement[] = this.breakUptext(text);\n        if (newLine) {\n            items.push(document.createElement(\"br\"));\n        }\n        this.writeToDisplay(items, over);\n        this.scrollToBottom();\n        return Promise.resolve();\n    }\n\n    scrollToBottom() {\n        this.display.scrollTo(0, this.display.scrollHeight);\n    }\n\n    prompt(show: boolean): void {\n        console.log(\"PROMPT\", show);\n    }\n\n\n    private processQueue(): void {\n        this.queuedItems.map((item: IQueuedDisplayItem) => {\n            this.writeToDisplay(item.text, item.over);\n        });\n    }\n\n    private createDisplay(): void {\n        this.display.id = \"output\";\n        this.display.tabIndex = -1;\n        this.display.classList.add(\"output\");\n        this.input.id = \"input\";\n        this.input.classList.add(\"input\");\n        this.input.tabIndex = 0;\n        this.input.contentEditable = \"true\";\n        this.input.spellcheck = false;\n        const body: HTMLBodyElement | null = document.querySelector(\"body\");\n        if (body !== null) {\n            body.append(this.display);\n            this.display.append(this.input);\n        }\n    }\n\n    private history(dir: 1 | -1): void {\n        this.specialUserInput(\"DIR\", dir.toString());\n    }\n\n    private controlKey(key: string): void {\n        this.inputOutput(false);\n        this.specialUserInput(\"CTRL\", key);\n    }\n\n    public setText(text: string): Promise<any> {\n        this.input.textContent = text;\n        const range = document.createRange() || new Range();\n        var sel: Selection = window.getSelection() || new Selection();\n        const childs = this.input.childNodes;\n        console.log(\"DISPLAY\", childs[childs.length - 1]);\n        if (text.length > 0) {\n            range.setStart(childs[childs.length - 1], this.input.textContent.length);\n        } else {\n            range.setStart(this.input, this.input.textContent.length);\n        }\n        range.collapse(true);\n        sel.removeAllRanges();\n        sel.addRange(range);\n        this.input.focus();\n        this.scrollToBottom();\n        return Promise.resolve();\n        // const range = document.createRange();//Create a range (a range is a like the selection but invisible)\n        // range.selectNodeContents(contentEditableElement);//Select the entire contents of the element with the range\n        // range.collapse(false);//collapse the range to the end point. false means collapse to end rather than the start\n        // selection = window.getSelection();//get the selection object (allows you to change selection)\n        // selection.removeAllRanges();//remove any selections already made\n        // selection.addRange(range);\n    }\n\n    private enterText(): void {\n        const text: string = this.inputOutput();\n        if (text.length > 0) {\n            this.userInput(text);\n            this.setText(\"\");\n        }\n    }\n\n    private inputOutput(newLine?: boolean): string {\n        newLine = newLine !== false;\n        const text: string = this.input.textContent || \"\";\n        if (text.length > 0) {\n            this.output(text, 0, newLine);\n        }\n        return text;\n    }\n\n    private specialUserInput(type: string, text: string): void {\n        this.userInput(\"\" + type + \"\" + text);\n    }\n\n    private userInput(text: string): void {\n        if (this.processManager !== null) {\n            this.processManager.stdIn(\"user\", text);\n        }\n    }\n\n    private tabKey(): void {\n        this.specialUserInput(\"tab\", this.input.textContent || \"\");\n    }\n}","import FS, { createRoot } from \"./Services/FileSystem\";\nimport Identity from \"./Struct/Identity\";\nimport ProcessManager from \"./Services/ProcessManager\";\nimport Display from \"./Services/Display\";\nimport { DefaultApps } from \"./App/Default/index\";\n// import xTermDisplay from \"./Services/xTermDisplay\";\n\nconst rootIdent: Identity = new Identity(\"root\", [], \"/\");\nconst guestIdent: Identity = new Identity(\"guest\", [], \"/home/guest\");\n\nconst InIframe: Function = (): boolean => {\n    try {\n        return window.self !== window.top;\n    } catch (e) {\n        return true;\n    }\n};\n\nconst isRemote: boolean = InIframe();\n\ncreateRoot(rootIdent);\n\nFS.mkdir(\"/bin\", rootIdent);\n\nFS.mkdir(\"/home\", rootIdent);\n\n// guest home\nFS.mkdir(\"/home/guest\", rootIdent)\n    .then(() => {\n        FS.chown(\"/home/guest\", rootIdent, \"guest\", \"guest\")\n            .then(() => {\n                FS.mkdir(\"/home/guest/bin\", guestIdent);\n                // tslint:disable-next-line\n                FS.write(\"/home/guest/test\", \"Lorem ipsum dolor sit amet, consectetur \\n\\n\\n\\n\\n\\n\\n adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\", guestIdent);\n                FS.mkdir(\"/home/guest/bin\", guestIdent);\n            });\n    });\n\n// root home\nFS.mkdir(\"/home/root\", rootIdent);\n\nObject.entries(DefaultApps).map((app: Array<any>) => {\n    FS.write(\"bin/\" + app[0], app[1].toString().replace(\"class{\", \"class Main{\"), rootIdent);\n    FS.chmod(\"bin/\" + app[0], rootIdent, \"755\");\n});\n\n\nconst display: Display = new Display();\nconst processManager: ProcessManager = new ProcessManager();\n\n// const xTerm: xTermDisplay = new xTermDisplay();\n\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    console.log(location.host, isRemote);\n\n    display.init(processManager);\n    processManager.init(display);\n    // xTerm.init(processManager);\n\n    display.output([\n        [\"Welcome to wlf.io TSPseudoOS v0.1 LTNS(Little To No Support)\"],\n        [\"\"],\n        [\"  * (TODO : D: )Try the command help to see what you can do\"],\n        [\"\"],\n        [\"Last Login: Fri, 25 Oct 2019 18: 57: 47 GMT\"],\n    ], 0, true);\n\n    processManager.startProcess(\"shell\", [], guestIdent);\n});\n","import FS from \"./FileSystem\";\n// import Process from \"../Struct/Process\";\nimport Identity, { IIdentity } from \"../Struct/Identity\";\n// import { IDisplayItem, AppMessage, AppMessageType } from \"../App/libOS\";\nimport { IDisplay, StubDisplay } from \"./Display\";\nimport Process from \"../Struct/Process\";\n\ninterface IPendingApp {\n    args: Array<any>;\n    resolve: Function;\n    reject: Function;\n}\n\nexport interface IProcessManager {\n    display: IDisplay | null;\n    stdIn(source: string | number, data: any): void;\n    startProcess(exec: string, params: string[], identity: Identity | null, parent?: any): Promise<any>;\n    endProcess(pid: number): void;\n    getDisplay(): IDisplay;\n    setEnv(pid: number, name: string, value: string): Promise<any>;\n}\n\nexport default class ProcessManager implements IProcessManager {\n    display: IDisplay | null = null;\n    processes: { [s: number]: Process } = {};\n    pids: number = 0;\n    pending: IPendingApp[] = [];\n    libJS: string | null = null;\n\n    mainProcess: Process | null = null;\n\n    setEnv(pid: number, name: string, value: string): Promise<any> {\n        if (this.processes.hasOwnProperty(pid)) {\n            this.processes[pid].setEnv(name, value);\n            return Promise.resolve();\n        }\n        return Promise.reject();\n    }\n\n    init(display: IDisplay): void {\n        this.display = display;\n    }\n\n    killProcess(processID: number): void {\n        const process: Process | null = this.getProcessFromID(processID);\n        if (process !== null) {\n            process.kill();\n        }\n    }\n\n    stdIn(source: string | number, data: any): void {\n        if (this.mainProcess !== null) {\n            this.mainProcess.stdIn(source, data);\n        } else {\n            console.log(\"STDIN\", data);\n        }\n    }\n\n    endProcess(pid: number): void {\n        if (this.processes.hasOwnProperty(pid)) {\n            delete this.processes[pid];\n        }\n    }\n\n    async startProcess(exec: string, params: string[], identity: IIdentity | null, parent?: Process): Promise<any> {\n        if (!(identity instanceof Identity)) {\n            if (parent instanceof Process) {\n                identity = parent.getIdentity();\n            }\n        }\n\n        if (!(identity instanceof Identity)) {\n            throw new Error(\"Identity is not identity\");\n        }\n\n        params = params.filter(s => s.length > 0);\n\n        try {\n            const execData: [string, string] = await FS.execRead(exec, identity);\n            this.pids++;\n            const execPath: string = execData[0];\n            const code: string = execData[1].trim();\n            const proc: Process = new Process(this, execPath, this.pids, params, identity, parent);\n\n            new Promise((res) => {\n                proc.start(code);\n                res();\n            }).then();\n\n            this.processes[this.pids] = proc;\n\n            if (this.mainProcess === null) {\n                this.mainProcess = proc;\n            }\n            return proc;\n        } catch (e) {\n            console.log([\"Process Error\", e]);\n            return Promise.reject([\"Process Error\", e]);\n        }\n    }\n\n    private getProcessFromID(id: number): Process | null {\n        return Object.values(this.processes).find(p => p.id === id) || null;\n    }\n\n    getDisplay(): IDisplay {\n        if (this.display !== null) {\n            return this.display;\n        }\n        return new StubDisplay();\n    }\n\n}","import { IProcessManager } from \"../Services/ProcessManager\";\nimport FS from \"../Services/FileSystem\";\nimport { FunctionSignature, IDisplayItem } from \"../App/libOS\";\nimport { OSApi } from \"./Types\";\nimport Identity, { IIdentityContainer, IIdentity } from \"./Identity\";\nimport OSLib from \"./OSLib\";\n\n\nexport interface IProcess {\n    id: number;\n    exec: string;\n    params: string[];\n    identity: IIdentity;\n    // parent: IProcess | null;\n    dead: boolean;\n    parentID: number;\n    identifier: string;\n}\n\nexport default class Process implements IProcess, IIdentityContainer {\n    manager: IProcessManager;\n    lib: OSLib;\n    code: string = \"\";\n\n    id: number;\n    identity: IIdentity;\n    params: string[];\n    exec: string;\n    dead: boolean = false;\n    children: { [s: number]: Process } = [];\n    app: any;\n\n    identifier: string;\n\n    parentInCB: Function | null = null;\n    parentEndCB: Function | null = null;\n    parentID: number = -1;\n\n    private api: OSApi = {\n        Std: {\n            out: (data: any) => this.hasParent() ? this.intoParent(data) : this.api.Display.print({ data: data, over: 0 }),\n            in: (data: any) => this.intoChild(data.pid, data.data, data.source || null),\n        },\n        FS: {\n            list: (data: string) => FS.list(data, this),\n            mkdir: (data: string) => FS.mkdir(data, this),\n            resolve: (data: string[]) => FS.resolveWorkingPaths(data, this),\n            append: (data: { path: string, content: string }) => FS.append(data.path, data.content, this),\n            write: (data: { path: string, content: string }) => FS.write(data.path, data.content, this),\n            touch: (path: string) => FS.touch(path, this),\n            read: (path: string) => FS.read(path, this),\n            del: (path: string) => FS.del(path, this),\n            dirExists: (path: string) => FS.dirExists(path, this),\n            fileExists: (path: string) => FS.fileExists(path, this),\n            delDir: (path: string) => FS.delDir(path, this),\n        },\n        Process: {\n            end: () => this.kill(),\n            setEnv: (data: { prop: string, value: any, pid?: number }) => this.setEnv(data.prop, data.value, data.pid),\n            self: () => Promise.resolve(this.data()),\n            start: (data: any) => this.manager.startProcess(data.exec, data.params, null, this),\n            crash: (error: any) => { this.api.Std.out(error); return this.kill(); },\n            changeWorkingPath: (data: { path: string, pid: number }) => this.changeWorkingPath(data.path, data.pid),\n            log: (...data: any) => this.log(...data),\n        },\n        Display: {\n            prompt: (text: string) => this.manager.getDisplay().setText(text),\n            print: (item: IDisplayItem) => this.manager.getDisplay().output(item.data, item.over, false),\n            printLn: (item: IDisplayItem) => this.manager.getDisplay().output(item.data, item.over, true),\n            info: () => this.manager.getDisplay().info(),\n        }\n    };\n\n    getIdentity(): IIdentity {\n        if (this.identity instanceof Identity) {\n            return this.identity.getIdentity();\n        } else {\n            return this.identity;\n        }\n    }\n\n    constructor(manager: IProcessManager, exec: string, pid: number, params: string[], identitC: IIdentity, parent?: Process) {\n        this.manager = manager;\n        this.exec = exec;\n        this.id = pid;\n        this.lib = new OSLib((signature: FunctionSignature, ...data: any) => this.call(signature, ...data));\n        this.identity = identitC.getIdentity();\n        this.params = params;\n        this.identifier = this.exec + \"[\" + this.id + \"]\";\n        if (parent instanceof Process) {\n            this.parentID = parent.id;\n            const cbs: [Function, Function] = parent.registerChild(this);\n            this.parentInCB = cbs[0];\n            this.parentEndCB = cbs[1];\n        }\n    }\n\n    setEnv(prop: string, value: any, pid?: number): Promise<any> {\n        if (typeof pid === \"number\") {\n            if (pid === this.parentID || this.children.hasOwnProperty(pid)) {\n                return this.manager.setEnv(pid, prop, value);\n            } else {\n                return Promise.reject();\n            }\n        } else {\n            switch (prop) {\n                case \"log\":\n                    console.log(\"Process SET\", value);\n                    break;\n                case \"workingPath\":\n                case \"workingDir\":\n                    this.changeWorkingPath(value);\n                    break;\n                default:\n                    this.identity.setEnv(prop, value);\n                    break;\n            }\n            this.event([\"Process\", \"self\"], this.data());\n            return Promise.resolve();\n        }\n    }\n\n    start(code: string): boolean {\n        this.code = code;\n        const wrapper: string = [\n            \"((proc,osLib)=>{\\n\",\n            this.code,\n            \";\\nreturn new Main(proc,osLib);\\n})\"\n        ].join(\"\");\n\n        // tslint:disable: no-eval\n        this.app = eval(wrapper)(this.data(), this.lib);\n        // tslint:enable: no-eval\n        return true;\n    }\n\n    hasParent(): boolean {\n        return this.parentID >= 0;\n    }\n\n    private intoParent(data: any): Promise<any> {\n        if (this.parentInCB !== null) {\n            this.log(\"Into parent\", data);\n            return this.parentInCB(data);\n        }\n        return Promise.reject();\n    }\n\n    call(signature: FunctionSignature, ...data: any): Promise<any> {\n        if (this.api.hasOwnProperty(signature.service)) {\n            if (this.api[signature.service].hasOwnProperty(signature.func)) {\n                return this.api[signature.service][signature.func](...data);\n            }\n        }\n        return Promise.reject(\n            new Error([\n                \"PM Error\",\n                \"Atempt to access non-existant System Call\\n\" + signature.service + \">\" + signature.func,\n                this.identifier\n            ].join(\" : \"))\n        );\n    }\n\n    data(): IProcess {\n        return {\n            id: this.id,\n            exec: this.exec,\n            params: [... this.params],\n            identity: this.identity,\n            dead: this.dead,\n            parentID: this.parentID,\n            identifier: this.identifier,\n        };\n    }\n\n    registerChild(process: Process): [Function, Function] {\n        this.children[process.id] = process;\n        const dat: IProcess = process.data();\n        return [\n            (data: any) => this.stdIn(dat.id, data),\n            () => this.removeChild(dat),\n        ];\n    }\n\n    removeChild(process: IProcess): Promise<any> {\n        this.event([\"Process\", \"end\"], process.id);\n        this.log(\"Removing Child\", process.identifier);\n        delete this.children[process.id];\n        return Promise.resolve();\n    }\n\n    intoChild(pid: number, source: number | string, data: any): Promise<any> {\n        if (this.children.hasOwnProperty(pid)) {\n            return this.children[pid].stdIn(source, data);\n        }\n        return Promise.reject();\n    }\n\n    stdIn(from: number | string, data: any): Promise<any> {\n        return this.event([\"Std\", \"in\"], { from, data });\n    }\n\n    async changeWorkingPath(path: string, pid?: number): Promise<any> {\n        if (typeof pid === \"number\" && pid > 0) {\n            this.manager.setEnv(pid, \"workingPath\", path);\n        } else {\n            this.identity.changeWorkingPath(path);\n        }\n    }\n\n    event(type: [string, string], data: any): Promise<any> {\n        return this.lib.fireEvent({ service: type[0], func: type[1] }, data);\n    }\n\n    kill(): Promise<any> {\n        this.dead = true;\n        delete this.app;\n        delete this.lib;\n        if (this.parentEndCB !== null) {\n            this.parentEndCB();\n        }\n        this.manager.endProcess(this.id);\n        this.log(\"KILLED\");\n        return Promise.resolve();\n    }\n\n    log(...data: any): Promise<any> {\n        console.log(this.exec + \"[\" + this.id + \"]\", ...data);\n        return Promise.resolve();\n    }\n}\n\n","import { ILibOS, ILibStd, ILibFS, IStdInMsg, ILibProcess, ILibDisplay, ILibUtil } from \"../App/libOS\";\nimport { FunctionSignature, PromiseHolder } from \"./Types\";\nimport { IProcess } from \"./Process\";\nimport Util from \"./Util\";\nimport CMD, { ILibCMD } from \"../Services/Cmd\";\n\nexport default class OSLib implements ILibOS {\n\n    private _call: (signature: FunctionSignature, ...data: any) => Promise<any>;\n    private hooks: { [s: string]: Function } = {};\n    private awaitProcs: { [s: number]: PromiseHolder } = {};\n\n    Std: ILibStd = {\n        event: {\n            in: (cb: (msg: IStdInMsg) => void) => this.hookEvent(\"Std\", \"in\", cb),\n        },\n        out: (data: any) => this.call(\"Std\", \"out\", data),\n        in: (pid: number, data: any, source?: string | number) => this.call(\"Std\", \"in\", { pid, data, source }),\n    };\n    FS: ILibFS = {\n        list: (path: string) => this.call(\"FS\", \"list\", path),\n        mkdir: (path: string) => this.call(\"FS\", \"mkdir\", path),\n        resolve: (paths: string[]) => this.call(\"FS\", \"resolve\", paths),\n        append: (path: string, content: string) => this.call(\"FS\", \"append\", { path, content }),\n        write: (path: string, content: string) => this.call(\"FS\", \"write\", { path, content }),\n        touch: (path: string) => this.call(\"FS\", \"touch\", path),\n        read: (path: string) => this.call(\"FS\", \"read\", path),\n        del: (path: string) => this.call(\"FS\", \"del\", path),\n        dirExists: (path: string) => this.call(\"FS\", \"dirExists\", path),\n        fileExists: (path: string) => this.call(\"FS\", \"fileExists\", path),\n        delDir: (path: string) => this.call(\"FS\", \"delDir\", path),\n    };\n    Process: ILibProcess = {\n        event: {\n            start: (cb: Function) => this.hookEvent(\"Process\", \"start\", cb),\n            msg: (cb: Function) => this.hookEvent(\"Process\", \"msg\", cb),\n            end: (cb: Function) => this.hookEvent(\"Process\", \"end\", cb),\n            self: (cb: Function) => this.hookEvent(\"Process\", \"self\", cb),\n        },\n        end: () => this.call(\"Process\", \"end\"),\n        // setSelf: (prop: string, value: any) => this.call(\"Process\", \"setSelf\", { prop, value }),\n        self: () => this.call(\"Process\", \"self\"),\n        start: (exec: string, params: string[]) => this.call(\"Process\", \"start\", { exec, params }),\n        crash: (error: any) => this.call(\"Process\", \"crash\", error),\n        changeWorkingPath: (path: string, pid?: number) => this.call(\"Process\", \"changeWorkingPath\", { path, pid }),\n        msg: (pid: number, msg: any) => this.call(\"Process\", \"msg\", { pid, msg }),\n        kill: (pid: number) => this.call(\"Process\", \"kill\", pid),\n        list: () => this.call(\"Process\", \"list\"),\n        startAndAwaitOutput: (exec: string, params: string[]) => this.startAndAwait(exec, params),\n        log: (...data: any) => this.call(\"Process\", \"log\", ...data),\n    };\n    Display: ILibDisplay = {\n        prompt: (text: string) => this.call(\"Display\", \"prompt\", text),\n        printRaw: (data: string | String[] | Array<string[]>, over: number, newLine: boolean) =>\n            this.call(\"Display\", \"print\", { data: data, over: over || 0, newLine: newLine === true }),\n        print: (data: string | String[] | Array<string[]>, over?: number) => this.Display.printRaw(data, over, false),\n        printLn: (data: string | String[] | Array<string[]>, over?: number) => this.Display.printRaw(data, over, true),\n        info: () => this.call(\"Display\", \"info\"),\n    };\n\n    Util: ILibUtil = Util;\n\n    CMD: ILibCMD = CMD;\n\n    constructor(call: (signature: FunctionSignature, ...data: any) => Promise<any>) {\n        this._call = call;\n    }\n\n    private call(service: string, func: string, ...data: any): Promise<any> {\n        return this._call({ service: service, func: func }, ...data);\n    }\n\n    private hookEvent(service: string, func: string, cb: Function): void {\n        const event: string = service + \":\" + func;\n        this.hooks[event] = cb;\n    }\n\n    private startAndAwait(exec: string, params: string[]): Promise<any> {\n        return new Promise((resolve, reject) => {\n            this.Process.start(exec, params)\n                .then((proc: IProcess) => {\n                    this.awaitProcs[proc.id] = {\n                        resolve: resolve,\n                        reject: reject,\n                    };\n                })\n                .catch(e => reject(e));\n        });\n    }\n\n    fireEvent(signature: FunctionSignature, data: any): Promise<any> {\n        return this.fireHooks(signature, data);\n    }\n\n    private awaitIn(msg: IStdInMsg): boolean {\n        if (typeof msg.from === \"number\" && this.awaitProcs.hasOwnProperty(msg.from)) {\n            this.awaitProcs[msg.from].resolve(msg);\n            delete this.awaitProcs[msg.from];\n            return true;\n        }\n        return false;\n    }\n\n    private fireHooks(signature: FunctionSignature, data: any): Promise<any> {\n        const event: string = signature.service + \":\" + signature.func;\n        if (event === \"Std:in\") {\n            if (this.awaitIn(data)) {\n                return Promise.resolve();\n            }\n        }\n        if (this.hooks.hasOwnProperty(event)) {\n            return this.hooks[event](data);\n        }\n        return Promise.reject(\"MISSING\");\n    }\n}","import { ILibUtil } from \"../App/libOS\";\n\nexport const Util: ILibUtil = {\n    loadArgs: (args, opts, map): Promise<string[]> => {\n        let remain: string[] = [];\n        for (let i: number = 0; i < args.length; i++) {\n            let arg: any = args[i];\n            if (arg.startsWith(\"--\") && arg.length > 2) {\n                arg = arg.slice(2);\n                if (opts.hasOwnProperty(arg)) {\n                    if (i < args.length - 1 && !args[i + 1].startsWith(\"-\") && typeof opts[arg] !== \"boolean\") {\n                        i++;\n                        opts[arg] = args[i];\n                    } else {\n                        opts[arg] = !opts[arg];\n                    }\n                } else {\n                    return Promise.reject(\n                        new Error(\n                            [\"Load Args Error\",\n                                \"unrecognized option '--\" + arg + \"'\\nTry '--help' for more information.\",\n                                JSON.stringify(args)\n                            ].join(\" : \"))\n                    );\n                }\n            } else if (arg.startsWith(\"-\") && arg.length > 1 && arg !== \"--\") {\n                arg = arg.slice(1);\n                for (let j = 0; j < arg.length; j++) {\n                    const shrt: string = arg.charAt(j);\n                    if (map.hasOwnProperty(shrt)) {\n                        opts[map[shrt]] = !opts[map[shrt]];\n                    }\n                }\n            } else {\n                remain = [...remain, arg];\n            }\n        }\n        return Promise.resolve(remain);\n    },\n    bytesToHuman: (bytes, kibi, bits) => {\n        kibi = kibi === true;\n        bits = bits === true;\n        if (bits) bytes *= 8;\n        const step = kibi ? 1000 : 1024;\n        const set =\n            bits ?\n                (kibi ? [\"b\", \"kb\", \"mb\", \"gb\", \"pb\"] : [\"b\", \"Kb\", \"Mb\", \"Gb\", \"Pb\"])\n                :\n                (kibi ? [\"B\", \"kB\", \"mB\", \"gB\", \"pB\"] : [\"B\", \"KB\", \"MB\", \"GB\", \"PB\"])\n            ;\n        let o = 0;\n\n        while (bytes > step) {\n            bytes /= step;\n            o++;\n        }\n        return Math.round(bytes) + set[o];\n    }\n};\n\nexport default Util;","import { ILibCMD } from \"./Cmd\";\r\n\r\nexport interface ILibCMD {\r\n    Colours: ILibCMDColours;\r\n    Colourize(text: string, fore: string, back?: string): string;\r\n}\r\n\r\nexport interface ILibCMDColours {\r\n    red: \"F00\";\r\n    green: \"0F0\";\r\n    blue: \"23F\";\r\n    black: \"000\";\r\n    white: \"FFF\";\r\n    lightBlue: \"38F\";\r\n}\r\n\r\nconst testColourHex: Function = (text: string): boolean => {\r\n    const re: RegExp = /[0-9A-F]{3}/g;\r\n    return re.test(text);\r\n};\r\n\r\nconst hexCheck: Function = (text: string, name: string): void => {\r\n    if (!testColourHex(text)) {\r\n        throw new Error([\"CMD Error\", name, \"Must be 3 hex chars\"].join(\" : \"));\r\n    }\r\n};\r\n\r\nconst CMD: ILibCMD = {\r\n    Colours: {\r\n        red: \"F00\",\r\n        green: \"0F0\",\r\n        blue: \"23F\",\r\n        black: \"000\",\r\n        white: \"FFF\",\r\n        lightBlue: \"38F\",\r\n    },\r\n    Colourize: (text: string, fore: string, back?: string) => {\r\n        back = back || \"000\";\r\n        back = back.toUpperCase();\r\n        fore = fore.toUpperCase();\r\n        hexCheck(fore);\r\n        hexCheck(back);\r\n        return \"\" + fore + back + text;\r\n    }\r\n};\r\n\r\nexport default CMD;","import ls from \"./ls\";\nimport shell from \"./shell\";\nimport mkdir from \"./mkdir\";\nimport cat from \"./cat\";\nimport touch from \"./touch\";\nimport rm from \"./rm\";\nimport cd from \"./cd\";\nimport tail from \"./tail\";\nimport head from \"./head\";\nimport edit from \"./edit\";\nimport help from \"./help\";\n\nexport const DefaultApps: { [s: string]: Function } = {\n    ls,\n    shell,\n    mkdir,\n    cat,\n    touch,\n    rm,\n    cd,\n    tail,\n    head,\n    edit,\n    help,\n};","import { IFSListEntry } from \"../../Services/FileSystem\";\nimport { ILibOS, AppOpts, AppOptsMap } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\n\nexport default class Main {\n    opts: AppOpts = {\n        all: false,\n        human: false,\n        long: false,\n        \"no-group\": false,\n        raw: false,\n    };\n    count: number = 0;\n    done: number = 0;\n\n    argMap: AppOptsMap = {\n        a: \"all\",\n        h: \"human\",\n        l: \"long\",\n        G: \"no-group\",\n    };\n\n    process: IProcess;\n    api: ILibOS;\n\n    constructor(process: IProcess, OS: ILibOS) {\n        this.process = process;\n        this.api = OS;\n        this.start(process.params);\n    }\n\n    async start(data: string[]) {\n        try {\n            let paths = await this.api.Util.loadArgs(data, this.opts, this.argMap);\n            this.count = paths.length;\n            if (this.count < 1) {\n                paths = [\"\"];\n                this.count = 1;\n            }\n            paths.map(s => this.list(s));\n        } catch (e) {\n            this.error(e);\n        }\n\n    }\n\n    formatFileName(entry: IFSListEntry): string {\n        let name: string = entry.name;\n        if (this.opts.raw) {\n            return name;\n        }\n        if (name.indexOf(\" \") >= 0) {\n            name = \"'\" + name + \"'\"\n        }\n        let fore: string = this.api.CMD.Colours.white;\n        let back: string = this.api.CMD.Colours.black;\n        if (!entry.file) {\n            fore = this.api.CMD.Colours.blue;\n        }\n        return this.api.CMD.Colourize(name, fore, back);\n    };\n\n    longOutputEntry(entry: IFSListEntry): any[] {\n        const out: { [s: string]: any } = {\n            perms: entry.perms,\n            user: entry.user,\n            group: entry.group,\n            size: entry.size,\n            name: this.formatFileName(entry),\n        };\n        if (this.opts[\"no-group\"]) {\n            delete out.group;\n        }\n        return Object.values(out);\n    };\n\n    longOutput(path: string, data: Array<IFSListEntry>): any[] {\n        let arr: Array<string[] | string> = [\n            path,\n            [\"perms\\t\", \"user\", this.opts[\"no-group\"] ? \"\" : \"group\", \"size\", \"name\"].filter(c => c.length > 0)\n        ];\n        data.map(d => this.longOutputEntry(d)).map(e => arr.push(e));\n        return arr;\n    }\n\n    shortOutput(data: Array<IFSListEntry>): string[] {\n        return data.map(e => this.formatFileName(e));\n    }\n\n    output(path: string, data: Array<IFSListEntry>) {\n        if (!this.opts.all) {\n            data = data.filter(d => !d.name.startsWith(\".\"));\n        }\n        if (this.opts.human) {\n            // todo : Human Sizes\n            // data.forEach(d => {\n            //     d.size = OS.Util.bytesToHuman(d.size);\n            // });\n        }\n        let result: string[] | Array<string[]>;\n        result = this.opts.long ? this.longOutput(path, data) : this.shortOutput(data);\n\n        this.api.Std.out(result);\n\n        this.done++;\n        if (this.done >= this.count) {\n            this.api.Process.end();\n        }\n    }\n\n    error(e: any) {\n        this.api.Process.crash(e);\n    }\n\n    async list(path: string) {\n        try {\n            const data: IFSListEntry[] = await this.api.FS.list(path);\n            this.output(path, data);\n        } catch (e) {\n            console.log(\"bob\", e);\n            this.error(e);\n        }\n    }\n}","import { ILibOS, IStdInMsg } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\nexport default class Main {\n    private bashHistoryFile: string = \"~/.bash_history\";\n\n    private bashProcess: IProcess;\n\n    private host: string = window.location.origin.split(\"://\")[1].split(\":\")[0] || \"[MISSING HOST]\";\n    private activeProcessID: number = -1;\n    private activeOutputed: boolean = false;\n\n    private subProcs: { [s: number]: IProcess } = {};\n\n    private history: string[] = [];\n    private historyPosition: number = 0;\n\n    private api: ILibOS;\n\n    constructor(process: IProcess, OS: ILibOS) {\n        this.bashProcess = process;\n        this.api = OS;\n        this.api.Process.event.self((proc: IProcess) => this.selfUpdate(proc));\n        this.api.Process.event.end((pid: number): Promise<any> => this.end(pid));\n        this.api.Std.event.in((data: IStdInMsg) => this.stdIn(data));\n        this.start();\n    }\n\n    setHistoryPosition(pos: number): void {\n        this.historyPosition = Math.min(Math.max(pos, 0), this.history.length);\n    }\n\n    showHistory(pos: number): void {\n        this.setHistoryPosition(pos);\n        this.api.Display.prompt(this.history[this.history.length - this.historyPosition]);\n    }\n\n    newHistory(input: string): void {\n        if (input.length > 0 && input !== this.history[this.history.length - 1]) {\n            this.history.push(input);\n            this.api.FS.append(this.bashHistoryFile, input + \"\\n\");\n        }\n        this.historyPosition = 0;\n    }\n\n    getSubProc(pid: number): IProcess | null {\n        if (this.subProcs.hasOwnProperty(pid)) {\n            return this.subProcs[pid];\n        }\n        return null;\n    }\n\n    printPrompt(newLine?: boolean): void {\n        newLine = newLine === true;\n        this.api.Std.out(\n            (newLine ? \"\\n\" : \"\")\n            +\n            this.api.CMD.Colourize(this.bashProcess.identity.user + \"@\" + this.host, this.api.CMD.Colours.green)\n            +\n            this.api.CMD.Colourize(\":\", this.api.CMD.Colours.white)\n            +\n            this.api.CMD.Colourize(this.getPromptPath(), this.api.CMD.Colours.blue)\n            +\n            this.api.CMD.Colourize(\"$ \", this.api.CMD.Colours.white)\n        );\n    }\n\n    getPromptPath(): string {\n        return this.bashProcess.identity.workingDir.replace(\"/home/\" + this.bashProcess.identity.user, \"~\");\n    }\n\n    splitUserInput(text: string): string[] {\n        const parts: string[] = text.match(/(\".*?\"|[^\" \\s]+)(?=\\s* |\\s*$)/g) || [];\n        return parts.map(s => {\n            s = s.trim();\n            if (s.charAt(0) === \"\\\"\" && s.charAt(s.length - 1) === \"\\\"\") {\n                s = s.slice(1, s.length - 1);\n            }\n            return s;\n        });\n    }\n\n    start(): void {\n        this.api.FS.read(this.bashHistoryFile)\n            .then((content: string) => {\n                this.history = content.split(\"\\n\")\n                    .filter(s => s.length > 0)\n                    .filter((s, i, a) => i > 0 && a[i - 1] !== s);\n            });\n        this.printPrompt();\n    }\n\n    resolveAppIn(msg: IStdInMsg): Promise<any> {\n        this.api.Process.log(\"stdIn From App\", msg, this.activeProcessID);\n        const proc: IProcess | null = this.getSubProc(parseInt(msg.from, 10));\n        let output: any = msg.data;\n        if (msg.data instanceof Array && proc !== null) {\n            if (msg.data[0] === \"ERROR\") {\n                output = proc.exec.split(\"/\").pop() + \": \" + msg.data[2];\n            }\n        }\n        if (parseInt(msg.from, 10) === this.activeProcessID) {\n            this.activeOutputed = true;\n        }\n        this.api.Std.out(output);\n        return Promise.resolve(\"asd\");\n    }\n\n    ctrlCode(type: string): void {\n        switch (type) {\n            case \"c\":\n                this.api.Std.out(\"^C\");\n                this.printPrompt(true);\n                this.api.Display.prompt(\"\");\n                break;\n        }\n    }\n\n    async tabComplete(text: string): Promise<any> {\n        const parts: string[] = this.splitUserInput(text);\n        let prompt: any = null;\n        if (parts.length === 1) {\n            console.log(\"TODO EXEC LISTING\");\n        } else {\n            const part: string = parts[parts.length - 1];\n            const dirs: string[] = part.split(\"/\");\n            const dir: string = dirs.slice(0, dirs.length - 1).join(\"/\");\n            const t: string = dirs[dirs.length - 1];\n            const args: string[] = [\"--raw\"];\n            if (t.startsWith(\".\")) {\n                args.push(\"--all\");\n            }\n            args.push(dir);\n            const ls: any = await this.api.Process.startAndAwaitOutput(\"ls\", args);\n            const opts: string[] = ls.data;\n            const result: string[] = opts.filter((e: string) => e.startsWith(t));\n            if (result.length === 1) {\n                dirs[dirs.length - 1] = result[0];\n                const d: string = dirs.join(\"/\");\n                const isDir: boolean = await this.api.FS.dirExists(d);\n                parts[parts.length - 1] = d + (isDir ? \"/\" : \"\");\n            } else {\n                prompt = opts;\n            }\n        }\n        if (prompt !== null) {\n            this.api.Std.out(text + \"\\n\");\n            this.api.Std.out(prompt);\n            this.printPrompt(true);\n        }\n        this.api.Display.prompt(parts.map((s: string) => s.indexOf(\" \") >= 0 ? \"\\\"\" + s + \"\\\"\" : s).join(\" \"));\n        return Promise.resolve();\n    }\n\n    specialCode(code: string): void {\n        const parts: string[] = code.split(\"\").filter(s => s.length > 0);\n        switch (parts[0].toLowerCase()) {\n            case \"ctrl\":\n                this.ctrlCode(parts[1]);\n                break;\n            case \"dir\":\n                this.showHistory(parseInt(parts[1], 10) + this.historyPosition);\n                break;\n            case \"tab\":\n                this.tabComplete(parts[1]);\n                break;\n            default:\n                console.log(\"SPECIAL CODE\", parts);\n                break;\n        }\n    }\n\n    selfUpdate(data: IProcess): Promise<any> {\n        this.bashProcess = data;\n        return Promise.resolve();\n    }\n\n    async stdIn(data: IStdInMsg): Promise<any> {\n        if (data.from === \"user\") {\n            if (typeof data.data === \"string\") {\n                if (data.data.startsWith(\"\")) {\n                    this.specialCode(data.data);\n                } else {\n                    if (this.activeProcessID > 0) {\n                        this.api.Std.in(this.activeProcessID, data.data, data.from);\n                        return;\n                    }\n                    if (data.data === \"exit\") {\n                        this.api.Process.end();\n                        return;\n                    }\n                    const parts: string[] = this.splitUserInput(data.data);\n                    const exec: string = parts.shift() || \"\";\n                    try {\n                        this.activeOutputed = false;\n                        const proc: any = await this.api.Process.start(exec, parts);\n                        this.subProcs[proc.id] = proc;\n                        this.activeProcessID = proc.id;\n                        this.api.Process.log(\"Proc Started\", proc);\n                    } catch (e) {\n                        console.log(\"EXEC ERROR\", e);\n                        try {\n                            if (e[1] === \"FS Error\" && e[3] === \"Not found\") {\n                                this.api.Std.out(exec + \": command not found\");\n                            } else {\n                                this.api.Std.out(e[1]);\n                            }\n                        } catch (er) {\n                            this.api.Std.out([\"BASH LAUNCH ERROR\", er.message]);\n                        }\n                        this.printPrompt(true);\n                    }\n                    this.newHistory(data.data);\n                }\n            }\n        } else {\n            const resolve: any = await this.resolveAppIn(data);\n            if (typeof resolve !== \"string\") {\n                console.log(resolve);\n            }\n        }\n        return Promise.resolve();\n    }\n    end(pid: number): Promise<any> {\n        const sub: IProcess | null = this.getSubProc(pid);\n        if (sub !== null) {\n            delete this.subProcs[pid];\n            if (pid === this.activeProcessID) {\n                this.activeProcessID = -1;\n                this.printPrompt(this.activeOutputed);\n            }\n        }\n        return Promise.resolve();\n    }\n}","import { ILibOS } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\nexport default class Main {\n\n    help: string[][] = [\n        [\"Usage: mkdir[OPTION]...DIRECTORY...\"],\n        [\"Create the DIRECTORY(ies), if they do not already exist.\"],\n        [\"\"],\n        [\"Mandatory arguments to long options are mandatory for short options too.\"],\n        //        [\"  - m, --mode= MODE\", \"set file mode(as in chmod), not a = rwx - umask\"],\n        [\"  - p, --parents\", \"no error if existing, make parent directories as needed\"],\n        [\"  - v, --verbose\", \"print a message for each created directory\"],\n        //        [\"  - Z\", \"\", \"\", \"set SELinux security context of each created directory\"],\n        //        [\"  \", \"\", \"\", \"to the default type\"],\n        [\"  \", \"--help\", \"\", \"display this help and exit\"],\n        [\"  \", \"--version\", \"output version information and exit\"],\n    ];\n\n    version: string = [\n        \"mkdir (GNU coreutils) 0.1\",\n        \"Copyright(C) 2010 wlf.io.\",\n        \"License MIT License < https://raw.githubusercontent.com/wlfio/TSPseudoOS/master/LICENSE >.\",\n        \"This is free software: you are free to change and redistribute it.\",\n        \"There is NO WARRANTY, to the extent permitted by law.\",\n        \"\",\n        \"Written by wlf.io.\"\n    ].join(\"\\n\");\n\n    options: { [s: string]: any } = {\n        help: false,\n        version: false,\n        verbose: false,\n        parents: false,\n    };\n    optMap: { [s: string]: string } = {\n        \"?\": \"help\",\n        v: \"verbose\",\n        p: \"parents\"\n    };\n\n    count: number = 0;\n    OS: ILibOS;\n\n    constructor(process: IProcess, OS: ILibOS) {\n        this.OS = OS;\n        this.start(process.params);\n    }\n\n    error(e: any) {\n        if (e instanceof Array) {\n            if (e[2] === \"Path is not directory\") {\n                e = new Error(\"MKDIR ERROR : no such file or directory '\" + e[3] + \"' : \" + e.join(\" : \"));\n            }\n        }\n        this.OS.Process.crash(e);\n    }\n\n    breakPathIntoParentPaths(path: string): string[] {\n        const parts: string[] = path.split(\"/\").filter(s => s.length > 0);\n        return parts.reduce((out: string[], inp: string, i: number) => {\n            if (i === 0) {\n                inp = \"/\" + inp;\n            } else {\n                inp = out[out.length - 1] + \"/\" + inp;\n            }\n            out.push(inp);\n            return out;\n        }, []);\n    }\n\n    breakPathsIntoParentPaths(paths: string[]): Array<string[]> {\n        return paths.map((path: string) => {\n            if (this.options.parents) {\n                return this.breakPathIntoParentPaths(path);\n            }\n            return [path];\n        });\n    }\n\n    async make(rawPaths: string[]): Promise<any> {\n        let prefix: string = \"\";\n        try {\n            const paths: string[] = await this.OS.FS.resolve(rawPaths);\n            console.log(\"PATHS\", paths);\n            const broken: string[][] = this.breakPathsIntoParentPaths(paths);\n            console.log(\"BROKEN\", broken);\n            for (let j: number = 0; j < broken.length; j++) {\n                const set: string[] = broken[j];\n                for (let i: number = 0; i < set.length; i++) {\n                    const path: string = set[i];\n                    const done: boolean = await this.OS.FS.mkdir(path);\n                    console.log(\"PATH DONE\", path, done);\n                    if (this.options.verbose && done) {\n                        this.OS.Std.out(prefix + \"created directory '\" + set[this.count] + \"'\");\n                    }\n                    if (!done && (!this.options.parents)) {\n                        this.OS.Std.out(prefix + \"cannot create directory '\" + set[this.count] + \"': File exists\");\n                    }\n                    prefix = \"\\n\";\n                }\n            }\n            this.OS.Process.end();\n        } catch (e) {\n            console.log(\"ERROROR\", e);\n            this.error(e);\n        }\n    }\n\n    async start(args: string[]) {\n        const params: string[] = await this.OS.Util.loadArgs(args, this.options, this.optMap);\n        if (params.length < 1 && !this.options.help && !this.options.version) {\n            this.OS.Process.crash(\n                new Error([\n                    \"mkdir error\",\n                    \"missing operand\\nTry 'mkdir --help' for more information\"\n                    , JSON.stringify(args)].join(\" : \")\n                )\n            );\n            return;\n        }\n        if (this.options.help) {\n            this.OS.Std.out(this.help);\n        } else if (this.options.version) {\n            this.OS.Std.out(this.version);\n        } else {\n            this.make(params);\n        }\n    };\n}","import { ILibOS, AppOptsMap, AppOpts } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\n\nexport default class Main {\n    options: AppOpts = {\n        number: false,\n        \"squeeze-blank\": false,\n    };\n\n    optMap: AppOptsMap = {\n        n: \"number\",\n        s: \"squeeze-blank\",\n    };\n\n    count: number = 0;\n\n    OS: ILibOS;\n\n    constructor(process: IProcess, OS: ILibOS) {\n        this.OS = OS;\n        this.start(process.params);\n    }\n\n    error(e: any) {\n        this.OS.Process.crash(e);\n    }\n\n    splitLines(content: string): string[][] {\n        const lines: string[][] = [];\n        let empty: boolean = false;\n        content.split(\"\\n\").forEach((txt: string) => {\n            this.count++;\n            if (txt.length < 1) {\n                if (empty) {\n                    return;\n                }\n                empty = true;\n            } else {\n                empty = false;\n            }\n            const line: string[] = [];\n            if (this.options.number) {\n                line.push(this.count.toString());\n            }\n            line.push(txt);\n            lines.push(line);\n        });\n        return lines;\n    }\n\n    output(content: string) {\n        this.OS.Std.out(this.splitLines(content));\n    }\n\n    async cat(paths: string[]): Promise<any> {\n        try {\n            for (let i: number = 0; i < paths.length; i++) {\n                const content: string | null = await this.OS.FS.read(paths[i]);\n                this.output(content);\n            }\n            this.OS.Process.end();\n        } catch (e) {\n            this.error(e);\n        }\n    }\n\n    async start(data: string[]) {\n        try {\n            const paths = await this.OS.Util.loadArgs(data, this.options, this.optMap);\n\n            if (paths.length < 1) {\n                throw new Error(\"CAT ERROR : you must include file path(s) : \" + JSON.stringify(data));\n            }\n            this.cat(paths);\n        } catch (e) {\n            console.log(\"CAT ERROR\", e);\n            this.error(e);\n        }\n    }\n}","import { ILibOS, AppOpts, AppOptsMap } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\nexport default class Main {\n    options: AppOpts = {\n        verbose: false,\n    };\n    optMap: AppOptsMap = {\n        v: \"verbose\",\n    };\n    OS: ILibOS;\n    constructor(process: IProcess, OS: ILibOS) {\n        this.OS = OS;\n        this.loadArgs(process.params);\n    }\n    firstOut: boolean = true;\n\n    async loadArgs(params: string[]): Promise<any> {\n        try {\n            const paths: string[] = await this.OS.Util.loadArgs(params, this.options, this.optMap);\n            this.run(paths);\n        } catch (e) {\n            this.error(e);\n        }\n    }\n\n    error(e: any): void {\n        this.OS.Process.crash(e);\n    }\n\n    async run(paths: string[]): Promise<any> {\n        for (let i: number = 0; i < paths.length; i++) {\n            const out: string[] = await this.OS.FS.touch(paths[i]);\n            this.printOutput(out);\n        }\n        this.OS.Process.end();\n    }\n\n    printOutput(out: string[]): void {\n        if (this.options.verbose) {\n            this.OS.Std.out((this.firstOut ? \"\" : \"\\n\") + \"created '\" + out[0] + \"'\");\n            this.firstOut = false;\n        }\n    }\n}","import { ILibOS, AppOpts, AppOptsMap } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\nexport default class Main {\n    options: AppOpts = {\n        verbose: false,\n        recursive: false,\n    };\n    optMap: AppOptsMap = {\n        v: \"verbose\",\n        r: \"recursive\",\n    }\n    OS: ILibOS;\n\n    constructor(process: IProcess, OS: ILibOS) {\n        this.OS = OS;\n        this.loadArgs(process.params);\n    }\n    firstOut: boolean = true;\n\n    async loadArgs(params: string[]) {\n        try {\n            const paths = await this.OS.Util.loadArgs(params, this.options, this.optMap);\n            this.run(paths);\n        } catch (e) {\n            this.error(e);\n        }\n    }\n\n    error(e: any): void {\n        this.OS.Process.crash(e);\n    }\n\n    async run(paths: string[]) {\n        try {\n            paths = await this.OS.FS.resolve(paths);\n            for (let i: number = 0; i < paths.length; i++) {\n                const path = paths[i];\n                const dir = await this.OS.FS.dirExists(path);\n                let out;\n                if (dir) {\n                    if (!this.options.recursive) {\n                        this.printDirError(path);\n                    } else {\n                        out = await this.OS.FS.delDir(path);\n                    }\n                } else {\n                    out = await this.OS.FS.del(path);\n                }\n                //const ls = await this.OS.FS.list(paths[i]);\n                //console.log(ls);\n                this.printOutput(out);\n            }\n            this.OS.Process.end();\n        } catch (e) {\n            this.error(e);\n        }\n    }\n\n    printOutput(out: any): void {\n        if (this.options.verbose) {\n            this.output(\"deleted '\" + out[0] + \"'\");\n        }\n    }\n\n    printDirError(path: string): void {\n        this.output(\"cannot remove '\" + path + \"' it's a directory\");\n    }\n\n    output(text: string) {\n        this.OS.Std.out((this.firstOut ? \"\" : \"\\n\") + \"rm: \" + text);\n        this.firstOut = false;\n    }\n}","import { ILibOS, AppOpts, AppOptsMap } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\nexport default class Main {\n    private api: ILibOS;\n    private proc: IProcess;\n    options: AppOpts = {\n    };\n    optMap: AppOptsMap = {\n    }\n    constructor(process: IProcess, OS: ILibOS) {\n        this.api = OS;\n        this.proc = process;\n        this.loadArgs(process.params);\n    }\n    firstOut: boolean = true;\n\n    async loadArgs(params: string[]) {\n        try {\n            const paths = await this.api.Util.loadArgs(params, this.options, this.optMap);\n            this.run(paths);\n        } catch (e) {\n            this.error(e);\n        }\n    }\n\n    error(e: any): void {\n        this.api.Process.crash(e);\n    }\n\n    async run(paths: string[]) {\n        try {\n            if (this.proc.parentID > 0) {\n                paths = await this.api.FS.resolve(paths);\n                const result = await this.api.Process.changeWorkingPath(paths[0], this.proc.parentID);\n                console.log(\"CHANGE DIR\", paths, result);\n            }\n            //console.log(PROCESS, paths);\n            this.api.Process.end();\n        } catch (e) {\n            this.error(e);\n        }\n    }\n};","import { ILibOS, AppOptsMap, AppOpts } from \"../libOS\";\nimport { IProcess } from \"../../Struct/Process\";\n\n\ndeclare var OS: ILibOS;\ndeclare var PROCESS: IProcess;\n\n\nconst tail: Function = () => {\n    class Tail {\n        options: AppOpts = {\n            follow: false,\n        };\n\n        optMap: AppOptsMap = {\n            f: \"follow\",\n        };\n\n        files: { [s: string]: string | null } = {};\n\n        constructor(process: IProcess) {\n            this.loadArgs(process.params);\n        }\n\n        error(e: any) {\n            OS.Process.crash(e);\n        }\n\n        async loadArgs(params: string[]) {\n            const paths = await OS.Util.loadArgs(params, this.options, this.options);\n            try {\n                await this.run(paths)\n            } catch (e) {\n                this.error(e);\n            }\n            console.log(paths);\n            OS.Process.end();\n        }\n\n        async run(paths: string[]) {\n\n            this.files = await this.readFiles(paths);\n\n            console.log(this.files);\n            if (this.options.follow) {\n\n            } else {\n                OS.Process.end();\n            }\n        }\n\n        async readFiles(paths: string[]) {\n            const files: { [s: string]: string | null } = {};\n            for (let i = 0; i < paths.length; i++) {\n                const path = paths[i];\n                files[path] = await OS.FS.read(path);\n            }\n            return files;\n        }\n    }\n\n    new Tail(PROCESS);\n};\n\nexport default tail;","export default class Main {\n    str: string;\n    constructor(str: string) {\n        this.str = str;\n    }\n}","export default class Main {\n    bob: number = 1;\n}","import { IProcess } from \"../../Struct/Process\";\r\nimport { ILibOS } from \"../libOS\";\r\nimport { AppOpts, AppOptsMap } from \"../../Struct/Types\";\r\n\r\n\r\nexport default class Main {\r\n    OS: ILibOS;\r\n\r\n    options: AppOpts = {\r\n\r\n    };\r\n\r\n    optMap: AppOptsMap = {\r\n\r\n    };\r\n\r\n    text: string[][] = [\r\n        [\"Help Text\"],\r\n        [\"Is Here\"],\r\n        [\"Line\"],\r\n        [\"Line\"],\r\n        [\"Line\"]\r\n    ];\r\n\r\n    constructor(process: IProcess, OS: ILibOS) {\r\n        this.OS = OS;\r\n        this.start(process.params);\r\n    }\r\n\r\n    async start(params: string[]): Promise<any> {\r\n        this.OS.Util.loadArgs(params, this.options, this.optMap);\r\n        await this.run();\r\n        this.OS.Process.end();\r\n    }\r\n\r\n    async run(): Promise<any> {\r\n        await this.OS.Std.out(this.text);\r\n    }\r\n}"],"sourceRoot":""}